{"version":3,"file":"static/chunks/5745.32f200d1c20c6ca4.js","mappings":"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","sources":["webpack://_N_E/./node_modules/graphql-ws/lib/utils.mjs","webpack://_N_E/./node_modules/graphql-ws/lib/common.mjs","webpack://_N_E/./node_modules/graphql-ws/lib/client.mjs","webpack://_N_E/./node_modules/graphql-ws/lib/index.mjs"],"sourcesContent":["/** @private */\nexport function extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nexport function isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nexport function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nexport function isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nexport function areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nexport function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n","/**\n *\n * common\n *\n */\nimport { areGraphQLErrors, extendedTypeof, isObject } from './utils.mjs';\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nexport const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nexport const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nexport var CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nexport var MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nexport function validateMessage(val) {\n    if (!isObject(val)) {\n        throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== 'string') {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n            }\n            if (typeof val.payload.query !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !isObject(val.payload.variables)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                extendedTypeof(val.payload.operationName) !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!areGraphQLErrors(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nexport function isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nexport function parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nexport function stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n","/**\n *\n * client\n *\n */\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { CloseCode, GRAPHQL_TRANSPORT_WS_PROTOCOL, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send(stringifyMessage({\n                        id,\n                        type: MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send(stringifyMessage({\n                                id,\n                                type: MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A synthetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nexport class TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000, // Normal Closure is not an erroneous close code\n        1001, // Going Away\n        1006, // Abnormal Closure\n        1005, // No Status Received\n        1012, // Service Restart\n        1013, // Try Again Later\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n","export * from './client.mjs';\nexport * from './server.mjs';\nexport * from './common.mjs';\n"],"names":["extendedTypeof","val","Array","isArray","isObject","limitCloseReason","reason","whenTooLong","length","validateMessage","type","MessageType","ConnectionInit","ConnectionAck","Ping","Pong","payload","Subscribe","id","query","variables","operationName","extensions","Next","Error","obj","every","ob","JSON","stringify","Complete","stringifyMessage","msg","replacer","CloseCode","__await","v","__asyncGenerator","thisArg","_arguments","generator","Symbol","asyncIterator","i","g","apply","q","Object","create","AsyncIterator","prototype","verb","f","Promise","resolve","then","reject","n","a","b","push","resume","r","value","fulfill","settle","e","shift","createClient","options","ws","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","retries","retryDelay","setTimeout","Math","floor","random","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","replace","c","toString","jsonMessageReplacer","jsonMessageReviver","reviver","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","listener","emit","_a","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","splice","indexOf","args","errorOrClosed","cb","listening","forEach","unlisten","err","locks","retrying","disposed","connect","clearTimeout","socket","throwOnClose","denied","connectionAckTimeout","queuedPing","undefined","code","enqueuePing","isFinite","readyState","OPEN","send","errOrEvent","TerminatedCloseEvent","close","onerror","onclose","onopen","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","data","parse","_","BadResponse","CLOSING","release","released","race","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","includes","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","next","finally","catch","iterate","request","pending","deferred","dispose","iterator","arguments","throw","return","terminate","constructor","name","wasClean"],"sourceRoot":""}