{"version":3,"file":"static/chunks/1942-a0f7b3ed8575b03f.js","mappings":"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","sources":["webpack://_N_E/./node_modules/graphql-tag/lib/index.js","webpack://_N_E/./node_modules/@apollo/client/react/hooks/useApolloClient.js","webpack://_N_E/./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js","webpack://_N_E/./node_modules/@apollo/client/react/hooks/internal/wrapHook.js","webpack://_N_E/./node_modules/@apollo/client/react/hooks/useQuery.js","webpack://_N_E/./node_modules/@apollo/client/react/parser/index.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_tagged_template_literal.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { getApolloContext } from \"../context/index.js\";\n/**\n * @example\n * ```jsx\n * import { useApolloClient } from '@apollo/client';\n *\n * function SomeComponent() {\n *   const client = useApolloClient();\n *   // `client` is now set to the `ApolloClient` instance being used by the\n *   // application (that was configured using something like `ApolloProvider`)\n * }\n * ```\n *\n * @since 3.0.0\n * @returns The `ApolloClient` instance being used by the application.\n */\nexport function useApolloClient(override) {\n    var context = React.useContext(getApolloContext());\n    var client = override || context.client;\n    invariant(!!client, 58);\n    return client;\n}\n//# sourceMappingURL=useApolloClient.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false;\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey];\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport var useSyncExternalStore = realHook ||\n    (function (subscribe, getSnapshot, getServerSnapshot) {\n        // Read the current snapshot from the store on every render. Again, this\n        // breaks the rules of React, and only works here because of specific\n        // implementation details, most importantly that updates are\n        // always synchronous.\n        var value = getSnapshot();\n        if (\n        // DEVIATION: Using __DEV__\n        globalThis.__DEV__ !== false &&\n            !didWarnUncachedGetSnapshot &&\n            // DEVIATION: Not using Object.is because we know our snapshots will never\n            // be exotic primitive values like NaN, which is !== itself.\n            value !== getSnapshot()) {\n            didWarnUncachedGetSnapshot = true;\n            // DEVIATION: Using invariant.error instead of console.error directly.\n            globalThis.__DEV__ !== false && invariant.error(68);\n        }\n        // Because updates are synchronous, we don't queue them. Instead we force a\n        // re-render whenever the subscribed state changes by updating an some\n        // arbitrary useState hook. Then, during render, we call getSnapshot to read\n        // the current value.\n        //\n        // Because we don't actually use the state returned by the useState hook, we\n        // can save a bit of memory by storing other stuff in that slot.\n        //\n        // To implement the early bailout, we need to track some things on a mutable\n        // object. Usually, we would put that in a useRef hook, but we can stash it in\n        // our useState hook instead.\n        //\n        // To force a re-render, we call forceUpdate({inst}). That works because the\n        // new object always fails an equality check.\n        var _a = React.useState({\n            inst: { value: value, getSnapshot: getSnapshot },\n        }), inst = _a[0].inst, forceUpdate = _a[1];\n        // Track the latest getSnapshot function with a ref. This needs to be updated\n        // in the layout phase so we can access it during the tearing check that\n        // happens on subscribe.\n        if (canUseLayoutEffect) {\n            // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n            // which may seem like a conditional hook, but this code ends up behaving\n            // unconditionally (one way or the other) because canUseLayoutEffect is\n            // constant.\n            React.useLayoutEffect(function () {\n                Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n                // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n                // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n            }, [subscribe, value, getSnapshot]);\n        }\n        else {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n        }\n        React.useEffect(function () {\n            // Check for changes right before subscribing. Subsequent changes will be\n            // detected in the subscription handler.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceUpdate({ inst: inst });\n            }\n            // Subscribe to the store and return a clean-up function.\n            return subscribe(function handleStoreChange() {\n                // TODO: Because there is no cross-renderer API for batching updates, it's\n                // up to the consumer of this library to wrap their subscription event\n                // with unstable_batchedUpdates. Should we try to detect when this isn't\n                // the case and print a warning in development?\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n            });\n            // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [subscribe]);\n        return value;\n    });\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map","var wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook(hookName, useHook, clientOrObsQuery) {\n    var queryManager = clientOrObsQuery[\"queryManager\"];\n    var wrappers = queryManager && queryManager[wrapperSymbol];\n    var wrapper = wrappers && wrappers[hookName];\n    return wrapper ? wrapper(useHook) : useHook;\n}\n//# sourceMappingURL=wrapHook.js.map","import { __assign, __rest } from \"tslib\";\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { ObservableQuery, NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { compact, isNonEmptyArray, maybeDeepFreeze, } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() { }\nvar lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useQuery\", \n    // eslint-disable-next-line react-compiler/react-compiler\n    useQuery_, useApolloClient(options && options.client))(query, options);\n}\nfunction useQuery_(query, options) {\n    var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;\n    return React.useMemo(function () { return (__assign(__assign({}, result), obsQueryFields)); }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n    function createInternalState(previous) {\n        var _a;\n        verifyDocumentType(query, DocumentType.Query);\n        var internalState = {\n            client: client,\n            query: query,\n            observable: \n            // See if there is an existing observable that was used to fetch the same\n            // data and if so, use it instead since it will contain the proper queryId\n            // to fetch the result set. This is used during SSR.\n            (renderPromises &&\n                renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n                ObservableQuery[\"inactiveOnCreation\"].withValue(!renderPromises, function () {\n                    return client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions()));\n                }),\n            resultData: {\n                // Reuse previousData from previous InternalState (if any) to provide\n                // continuity of previousData even if/when the query or client changes.\n                previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data,\n            },\n        };\n        return internalState;\n    }\n    var _a = React.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];\n    /**\n     * Used by `useLazyQuery` when a new query is executed.\n     * We keep this logic here since it needs to update things in unsafe\n     * ways and here we at least can keep track of that in a single place.\n     */\n    function onQueryExecuted(watchQueryOptions) {\n        var _a;\n        var _b;\n        // this needs to be set to prevent an immediate `resubscribe` in the\n        // next rerender of the `useQuery` internals\n        Object.assign(internalState.observable, (_a = {},\n            _a[lastWatchOptions] = watchQueryOptions,\n            _a));\n        var resultData = internalState.resultData;\n        updateInternalState(__assign(__assign({}, internalState), { \n            // might be a different query\n            query: watchQueryOptions.query, resultData: Object.assign(resultData, {\n                // We need to modify the previous `resultData` object as we rely on the\n                // object reference in other places\n                previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n                current: undefined,\n            }) }));\n    }\n    if (client !== internalState.client || query !== internalState.query) {\n        // If the client or query have changed, we need to create a new InternalState.\n        // This will trigger a re-render with the new state, but it will also continue\n        // to run the current render function to completion.\n        // Since we sometimes trigger some side-effects in the render function, we\n        // re-assign `state` to the new state to ensure that those side-effects are\n        // triggered with the new state.\n        var newInternalState = createInternalState(internalState);\n        updateInternalState(newInternalState);\n        return [newInternalState, onQueryExecuted];\n    }\n    return [internalState, onQueryExecuted];\n}\nexport function useQueryInternals(query, options) {\n    var client = useApolloClient(options.client);\n    var renderPromises = React.useContext(getApolloContext()).renderPromises;\n    var isSyncSSR = !!renderPromises;\n    var disableNetworkFetches = client.disableNetworkFetches;\n    var ssrAllowed = options.ssr !== false && !options.skip;\n    var partialRefetch = options.partialRefetch;\n    var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n    var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];\n    var watchQueryOptions = makeWatchQueryOptions(observable);\n    useResubscribeIfNecessary(resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client, options, watchQueryOptions);\n    var obsQueryFields = React.useMemo(function () { return bindObservableMethods(observable); }, [observable]);\n    useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n    var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n        onCompleted: options.onCompleted || noop,\n        onError: options.onError || noop,\n    });\n    return {\n        result: result,\n        obsQueryFields: obsQueryFields,\n        observable: observable,\n        resultData: resultData,\n        client: client,\n        onQueryExecuted: onQueryExecuted,\n    };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n    var callbackRef = React.useRef(callbacks);\n    React.useEffect(function () {\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        // eslint-disable-next-line react-compiler/react-compiler\n        callbackRef.current = callbacks;\n    });\n    var resultOverride = ((isSyncSSR || disableNetworkFetches) &&\n        options.ssr === false &&\n        !options.skip) ?\n        // If SSR has been explicitly disabled, and this function has been called\n        // on the server side, return the default loading state.\n        ssrDisabledResult\n        : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            skipStandbyResult\n            : void 0;\n    var previousData = resultData.previousData;\n    var currentResultOverride = React.useMemo(function () {\n        return resultOverride &&\n            toQueryResult(resultOverride, previousData, observable, client);\n    }, [client, observable, resultOverride, previousData]);\n    return useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n        if (isSyncSSR) {\n            return function () { };\n        }\n        var onNext = function () {\n            var previousResult = resultData.current;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            var result = observable.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                equal(previousResult.data, result.data)) {\n                return;\n            }\n            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n        };\n        var onError = function (error) {\n            subscription.current.unsubscribe();\n            subscription.current = observable.resubscribeAfterError(onNext, onError);\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                // The error is not a GraphQL error\n                throw error;\n            }\n            var previousResult = resultData.current;\n            if (!previousResult ||\n                (previousResult && previousResult.loading) ||\n                !equal(error, previousResult.error)) {\n                setResult({\n                    data: (previousResult &&\n                        previousResult.data),\n                    error: error,\n                    loading: false,\n                    networkStatus: NetworkStatus.error,\n                }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n            }\n        };\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        var subscription = { current: observable.subscribe(onNext, onError) };\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return function () {\n            setTimeout(function () { return subscription.current.unsubscribe(); });\n        };\n    }, [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n    ]), function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    }, function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n    if (renderPromises && ssrAllowed) {\n        renderPromises.registerSSRObservable(observable);\n        if (observable.getCurrentResult().loading) {\n            // TODO: This is a legacy API which could probably be cleaned up\n            renderPromises.addObservableQueryPromise(observable);\n        }\n    }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(\n/** this hook will mutate properties on `resultData` */\nresultData, \n/** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n    var _a;\n    if (observable[lastWatchOptions] &&\n        !equal(observable[lastWatchOptions], watchQueryOptions)) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        resultData.previousData =\n            ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n        resultData.current = void 0;\n    }\n    observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n    if (_a === void 0) { _a = {}; }\n    var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    return function (observable) {\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: query });\n        if (isSyncSSR &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            watchQueryOptions.initialFetchPolicy =\n                watchQueryOptions.initialFetchPolicy ||\n                    watchQueryOptions.fetchPolicy ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n            watchQueryOptions.fetchPolicy = \"standby\";\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n        }\n        return watchQueryOptions;\n    };\n}\nexport function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n    var toMerge = [];\n    var globalDefaults = client.defaultOptions.watchQuery;\n    if (globalDefaults)\n        toMerge.push(globalDefaults);\n    if (queryHookOptions.defaultOptions) {\n        toMerge.push(queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(observable && observable.options, watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n    var previousResult = resultData.current;\n    if (previousResult && previousResult.data) {\n        resultData.previousData = previousResult.data;\n    }\n    if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n        // Until a set naming convention for networkError and graphQLErrors is\n        // decided upon, we map errors (graphQLErrors) to the error options.\n        // TODO: Is it possible for both result.error and result.errors to be\n        // defined here?\n        nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });\n    }\n    resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    forceUpdate();\n    handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n    if (!result.loading) {\n        var error_1 = toApolloError(result);\n        // wait a tick in case we are in the middle of rendering a component\n        Promise.resolve()\n            .then(function () {\n            if (error_1) {\n                callbacks.onError(error_1);\n            }\n            else if (result.data &&\n                previousNetworkStatus !== result.networkStatus &&\n                result.networkStatus === NetworkStatus.ready) {\n                callbacks.onCompleted(result.data);\n            }\n        })\n            .catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.warn(error);\n        });\n    }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!resultData.current) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        // this could call unsafeHandlePartialRefetch\n        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () { }, callbacks);\n    }\n    return resultData.current;\n}\nexport function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n    var _a;\n    return ((queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) ||\n        ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n        \"cache-first\");\n}\nexport function toApolloError(result) {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n        : result.error;\n}\nexport function toQueryResult(result, previousData, observable, client) {\n    var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    var queryResult = __assign(__assign({ data: data }, resultWithoutPartial), { client: client, observable: observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData: previousData });\n    return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial &&\n        partialRefetch &&\n        !result.loading &&\n        (!result.data || Object.keys(result.data).length === 0) &&\n        observable.options.fetchPolicy !== \"cache-only\") {\n        observable.refetch();\n        return __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });\n    }\n    return result;\n}\nvar ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n});\nvar skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n});\nfunction bindObservableMethods(observable) {\n    return {\n        refetch: observable.refetch.bind(observable),\n        reobserve: observable.reobserve.bind(observable),\n        fetchMore: observable.fetchMore.bind(observable),\n        updateQuery: observable.updateQuery.bind(observable),\n        startPolling: observable.startPolling.bind(observable),\n        stopPolling: observable.stopPolling.bind(observable),\n        subscribeToMore: observable.subscribeToMore.bind(observable),\n    };\n}\n//# sourceMappingURL=useQuery.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport { AutoCleanedWeakCache, cacheSizes, } from \"../../utilities/index.js\";\nimport { registerGlobalCache } from \"../../utilities/caching/getMemoryInternals.js\";\nexport var DocumentType;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\nvar cache;\nexport function operationName(type) {\n    var name;\n    switch (type) {\n        case DocumentType.Query:\n            name = \"Query\";\n            break;\n        case DocumentType.Mutation:\n            name = \"Mutation\";\n            break;\n        case DocumentType.Subscription:\n            name = \"Subscription\";\n            break;\n    }\n    return name;\n}\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document) {\n    if (!cache) {\n        cache = new AutoCleanedWeakCache(cacheSizes.parser || 1000 /* defaultCacheSizes.parser */);\n    }\n    var cached = cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n    invariant(!!document && !!document.kind, 70, document);\n    var fragments = [];\n    var queries = [];\n    var mutations = [];\n    var subscriptions = [];\n    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {\n        var x = _a[_i];\n        if (x.kind === \"FragmentDefinition\") {\n            fragments.push(x);\n            continue;\n        }\n        if (x.kind === \"OperationDefinition\") {\n            switch (x.operation) {\n                case \"query\":\n                    queries.push(x);\n                    break;\n                case \"mutation\":\n                    mutations.push(x);\n                    break;\n                case \"subscription\":\n                    subscriptions.push(x);\n                    break;\n            }\n        }\n    }\n    invariant(!fragments.length ||\n        queries.length ||\n        mutations.length ||\n        subscriptions.length, 71);\n    invariant(\n        queries.length + mutations.length + subscriptions.length <= 1,\n        72,\n        document,\n        queries.length,\n        subscriptions.length,\n        mutations.length\n    );\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = DocumentType.Subscription;\n    var definitions = queries.length ? queries\n        : mutations.length ? mutations\n            : subscriptions;\n    invariant(definitions.length === 1, 73, document, definitions.length);\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === \"Name\") {\n        name = definition.name.value;\n    }\n    else {\n        name = \"data\"; // fallback to using data if no name\n    }\n    var payload = { name: name, type: type, variables: variables };\n    cache.set(document, payload);\n    return payload;\n}\nparser.resetCache = function () {\n    cache = undefined;\n};\nif (globalThis.__DEV__ !== false) {\n    registerGlobalCache(\"parser\", function () { return (cache ? cache.size : 0); });\n}\nexport function verifyDocumentType(document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    invariant(\n        operation.type === type,\n        74,\n        requiredOperationName,\n        requiredOperationName,\n        usedOperationName\n    );\n}\n//# sourceMappingURL=index.js.map","export function _tagged_template_literal(strings, raw) {\n    if (!raw) raw = strings.slice(0);\n\n    return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));\n}\nexport { _tagged_template_literal as _ };\n"],"names":["gql_1","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","gql","literals","args","_i","arguments","length","result","forEach","arg","i","kind","loc","source","body","parseDocument","cacheKey","has","seenKeys","definitions","doc","workSet","parsed","graphql__WEBPACK_IMPORTED_MODULE_1__","Qc","allowLegacyFragmentVariables","set","Set","ast","fragmentDefinition","fragmentName","name","value","sourceKey","substring","start","end","sourceKeySet","get","console","warn","add","push","tslib__WEBPACK_IMPORTED_MODULE_0__","pi","node","Object","keys","key","startToken","endToken","resetCaches","clear","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","useApolloClient","override","context","rehackt__WEBPACK_IMPORTED_MODULE_1__","useContext","_context_index_js__WEBPACK_IMPORTED_MODULE_2__","K","client","_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__","kG","didWarnUncachedGetSnapshot","useSyncExternalStore","realHook","subscribe","getSnapshot","getServerSnapshot","globalThis","__DEV__","globals","error","_a","rehackt","useState","inst","forceUpdate","canUse","JC","useLayoutEffect","assign","checkIfSnapshotChanged","useEffect","_b","wrapperSymbol","Symbol","for","useQuery_hasOwnProperty","prototype","hasOwnProperty","noop","lastWatchOptions","useQuery","query","options","useHook","queryManager","wrappers","wrapper","create","wrapHook","useQuery_","clientOrObsQuery","x","skip","defaultOptions","otherOptions","renderPromises","isSyncSSR","disableNetworkFetches","ssrAllowed","partialRefetch","makeWatchQueryOptions","observable","resultData","onQueryExecuted","watchQueryOptions","obsQueryFields","callbacks","callbackRef","resultOverride","previousData","currentResultOverride","ApolloContext","ssr","onCompleted","onError","tslib_es6","_T","fetchPolicy","variables","initialFetchPolicy","getDefaultFetchPolicy","useInternalState","createInternalState","previous","parser","Vp","n_","Query","getSSRObservable","ObservableQuery","u","withValue","watchQuery","getObsQueryOptions","current","data","internalState","updateInternalState","undefined","newInternalState","lib","D","reobserve","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","registerSSRObservable","getCurrentResult","loading","addObservableQueryPromise","useRef","ssrDisabledResult","skipStandbyResult","toQueryResult","useCallback","handleStoreChange","onNext","previousResult","networkStatus","setResult","subscription","unsubscribe","resubscribeAfterError","call","Ie","setTimeout","queryHookOptions","toMerge","globalDefaults","compact","o","reduce","mergeOptions","J","nextResult","arrays","O","errors","cA","graphQLErrors","partial","handleErrorOrCompleted","previousNetworkStatus","error_1","Promise","resolve","then","ready","catch","queryHookDefaultOptions","clientDefaultOptions","resultWithoutPartial","called","maybeDeepFreeze","DocumentType","cache","operationName","type","Mutation","Subscription","document","_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__","s","_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__","Q","cached","fragments","queries","mutations","subscriptions","operation","definition","variableDefinitions","payload","verifyDocumentType","requiredOperationName","usedOperationName","resetCache","_utilities_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_3__","zP","size","_tagged_template_literal","strings","raw","slice","freeze","defineProperties"],"sourceRoot":""}