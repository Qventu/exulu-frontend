{"version":3,"file":"static/chunks/1713-0e65ea6337f161ac.js","mappings":"6JA8DAA,EAAA,IA3DA,cAAiCC,EAAAC,CAAY,CAC7C,CAAAC,CAAA,EACAC,CAAA,EACAC,CAAA,cACA,CACA,QACA,MAAAA,CAAA,KACA,IAAWC,EAAAC,EAAQ,EAAAC,OAAAC,gBAAA,EACnB,IAAAC,EAAA,IAAAC,IAEA,OADAH,OAAAC,gBAAA,oBAAAC,EAAA,IACA,KACAF,OAAAI,mBAAA,oBAAAF,EACA,CACA,CAEA,CACA,CACAG,aAAA,CACA,MAAAT,CAAA,EACA,KAAAU,gBAAA,OAAAT,CAAA,CAEA,CACAU,eAAA,CACA,KAAAC,YAAA,KACA,MAAAZ,CAAA,KACA,MAAAA,CAAA,QAEA,CACAU,iBAAAT,CAAA,EACA,MAAAA,CAAA,CAAAA,EACA,MAAAD,CAAA,KACA,MAAAA,CAAA,CAAAC,EAAA,IACA,kBAAAF,EACA,KAAAc,UAAA,CAAAd,GAEA,KAAAQ,OAAA,EAEA,EACA,CACAM,WAAAd,CAAA,EACA,MAAAA,CAAA,GAAAA,IAEA,MAAAA,CAAA,CAAAA,EACA,KAAAQ,OAAA,GAEA,CACAA,SAAA,CACA,IAAAO,EAAA,KAAAA,SAAA,GACA,KAAAC,SAAA,CAAAC,OAAA,KACAV,EAAAQ,EACA,EACA,CACAA,WAAA,OACA,wBAAAf,CAAA,CACA,MAAAA,CAAA,CAEAkB,WAAAC,QAAA,EAAAC,kBAAA,QACA,CACA,0DC5DA,IAAAC,EAAA,GAAAC,WAAAC,EAAA,GA6EAC,EAAAC,WA3EA,IAAAC,EAAA,GACAC,EAAA,EACAC,EAAA,IACAC,GACA,EACAC,EAAA,IACAD,GACA,EACAE,EAAAV,EACAW,EAAA,IACAL,EACAD,EAAAO,IAAA,CAAAJ,GAEAE,EAAA,KACAH,EAAAC,EACA,EAEA,EACAK,EAAA,KACA,IAAAC,EAAAT,EACAA,EAAA,GACAS,EAAAC,MAAA,EACAL,EAAA,KACAD,EAAA,KACAK,EAAAlB,OAAA,KACAW,EAAAC,EACA,EACA,EACA,EAEA,EACA,OACAQ,MAAA,IACA,IAAAC,CACAX,CAAAA,IACA,IACAW,EAAAT,GACA,QAAQ,GAERF,GACAO,GAEA,CACA,OAAAI,CACA,EAIAC,WAAA,GACA,IAAAC,KACAR,EAAA,KACAH,KAAAW,EACA,EACA,EAEAR,SAAAA,EAKAS,kBAAA,IACAb,EAAAc,CACA,EAKAC,uBAAA,IACAb,EAAAY,CACA,EACAE,aAAA,IACAb,EAAAW,CACA,CACA,CACA,qFCzBAG,EAAA,IAjDA,cAAkC/C,EAAAC,CAAY,CAC9C,CAAA+C,CAAA,KACA7C,CAAA,EACAC,CAAA,cACA,CACA,QACA,MAAAA,CAAA,KACA,IAAWC,EAAAC,EAAQ,EAAAC,OAAAC,gBAAA,EACnB,IAAAyC,EAAA,IAAAC,EAAA,IACAC,EAAA,IAAAD,EAAA,IAGA,OAFA3C,OAAAC,gBAAA,UAAAyC,EAAA,IACA1C,OAAAC,gBAAA,WAAA2C,EAAA,IACA,KACA5C,OAAAI,mBAAA,UAAAsC,GACA1C,OAAAI,mBAAA,WAAAwC,EACA,CACA,CAEA,CACA,CACAvC,aAAA,CACA,MAAAT,CAAA,EACA,KAAAU,gBAAA,OAAAT,CAAA,CAEA,CACAU,eAAA,CACA,KAAAC,YAAA,KACA,MAAAZ,CAAA,KACA,MAAAA,CAAA,QAEA,CACAU,iBAAAT,CAAA,EACA,MAAAA,CAAA,CAAAA,EACA,MAAAD,CAAA,KACA,MAAAA,CAAA,CAAAC,EAAA,KAAAgD,SAAA,CAAAC,IAAA,OACA,CACAD,UAAAJ,CAAA,EACA,MAAAA,CAAA,GAAAA,IAEA,MAAAA,CAAA,CAAAA,EACA,KAAA9B,SAAA,CAAAC,OAAA,KACAV,EAAAuC,EACA,GAEA,CACAM,UAAA,CACA,aAAAN,CAAA,CAEA,+HCtCAO,EAAA,cAA0BC,EAAAC,CAAS,CACnC,CAAAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,aACAC,CAAA,EACA,QACA,MAAAD,CAAA,IACA,MAAAD,CAAA,CAAAE,EAAAF,cAAA,CACA,KAAAG,UAAA,CAAAD,EAAAE,OAAA,EACA,KAAAC,SAAA,IACA,MAAAP,CAAA,CAAAI,EAAAJ,MAAA,CACA,MAAAD,CAAA,OAAAC,CAAA,CAAAQ,aAAA,GACA,KAAAC,QAAA,CAAAL,EAAAK,QAAA,CACA,KAAAC,SAAA,CAAAN,EAAAM,SAAA,CACA,MAAAb,CAAA,CAAAc,SAiWAL,CAAA,EACA,IAAAM,EAAA,mBAAAN,EAAAO,WAAA,CAAAP,EAAAO,WAAA,GAAAP,EAAAO,WAAA,CACAC,EAAAF,KAAA,IAAAA,EACAG,EAAAD,EAAA,mBAAAR,EAAAS,oBAAA,CAAAT,EAAAS,oBAAA,GAAAT,EAAAS,oBAAA,GACA,OACAH,KAAAA,EACAI,gBAAA,EACAC,cAAAH,EAAAC,GAAAG,KAAAC,GAAA,KACAC,MAAA,KACAC,iBAAA,EACAC,eAAA,EACAC,kBAAA,EACAC,mBAAA,KACAC,UAAA,KACAC,cAAA,GACAC,OAAAb,EAAA,oBACAc,YAAA,MACA,CACA,EAnXA,KAAAtB,OAAA,EACA,KAAAuB,KAAA,CAAAzB,EAAAyB,KAAA,QAAAhC,CAAA,CACA,KAAAiC,UAAA,EACA,CACA,IAAAC,MAAA,CACA,YAAAzB,OAAA,CAAAyB,IAAA,CAEA,IAAAC,SAAA,CACA,aAAA/B,CAAA,EAAA+B,OACA,CACA3B,WAAAC,CAAA,EACA,KAAAA,OAAA,EAAqB,SAAAJ,CAAA,IAAAI,CAAA,EACrB,KAAA2B,YAAA,MAAA3B,OAAA,CAAA4B,MAAA,CACA,CACAC,gBAAA,CACA,KAAA5B,SAAA,CAAA9B,MAAA,gBAAAoD,KAAA,CAAAD,WAAA,EACA,MAAA7B,CAAA,CAAAqC,MAAA,MAEA,CACAC,QAAAC,CAAA,CAAAhC,CAAA,EACA,IAAAM,EAAiB,GAAApE,EAAA+F,EAAA,EAAW,KAAAV,KAAA,CAAAjB,IAAA,CAAA0B,EAAA,KAAAhC,OAAA,EAO5B,OANA,MAAAkC,CAAA,EACA5B,KAAAA,EACA6B,KAAA,UACAxB,cAAAX,GAAAoC,UACAC,OAAArC,GAAAqC,MACA,GACA/B,CACA,CACAgC,SAAAf,CAAA,CAAAgB,CAAA,EACA,MAAAL,CAAA,EAAqBC,KAAA,WAAAZ,MAAAA,EAAAgB,gBAAAA,CAAA,EACrB,CACAC,OAAAxC,CAAA,EACA,IAAA0B,EAAA,MAAA/B,CAAA,EAAA+B,QAEA,OADA,MAAA/B,CAAA,EAAA6C,OAAAxC,GACA0B,EAAAA,EAAAe,IAAA,CAAkCvG,EAAAwG,EAAI,EAAAC,KAAA,CAAQzG,EAAAwG,EAAI,EAAAE,QAAAC,OAAA,EAClD,CACAC,SAAA,CACA,MAAAA,UACA,KAAAN,MAAA,EAAkBO,OAAA,IAClB,CACAC,OAAA,CACA,KAAAF,OAAA,GACA,KAAAR,QAAA,OAAA/C,CAAA,CACA,CACA0D,UAAA,CACA,YAAAhD,SAAA,CAAAiD,IAAA,CACA,GAAoB,CAAc,IAAd,GAAAhH,EAAAiH,EAAA,EAAcC,EAAApD,OAAA,CAAAqD,OAAA,OAElC,CACAC,YAAA,QACA,KAAAC,iBAAA,KACA,MAAAN,QAAA,GAEA,KAAAjD,OAAA,CAAAwD,OAAA,GAAoCtH,EAAAuH,EAAS,OAAAlC,KAAA,CAAAb,eAAA,MAAAa,KAAA,CAAAR,gBAAA,IAC7C,CACA2C,UAAA,QACA,KAAAH,iBAAA,MACA,KAAAtD,SAAA,CAAAiD,IAAA,CACA,GAAsB,cAAAhH,EAAAyH,EAAA,EAAgBP,EAAApD,OAAA,CAAA4D,SAAA,OAItC,CACAC,SAAA,QACA,KAAAN,iBAAA,KACA,KAAAtD,SAAA,CAAAiD,IAAA,CACA,GAAAE,EAAAU,gBAAA,GAAAD,OAAA,EAGA,cAAAtC,KAAA,CAAAjB,IAAA,OAAAiB,KAAA,CAAAH,aAAA,CAEA2C,cAAAH,EAAA,UACA,cAAArC,KAAA,CAAAjB,IAAA,EAGA,WAAAsD,MAGA,KAAArC,KAAA,CAAAH,aAAA,EAGA,CAAY,GAAAlF,EAAA8H,EAAA,EAAc,KAAAzC,KAAA,CAAAZ,aAAA,CAAAiD,GAC1B,CACArH,SAAA,CACA,IAAA6G,EAAA,KAAAnD,SAAA,CAAAgE,IAAA,IAAAC,EAAAC,wBAAA,IACAf,GAAAgB,QAAA,CAAwBC,cAAA,KACxB,MAAA1E,CAAA,EAAA2E,UACA,CACAvF,UAAA,CACA,IAAAqE,EAAA,KAAAnD,SAAA,CAAAgE,IAAA,IAAAC,EAAAK,sBAAA,IACAnB,GAAAgB,QAAA,CAAwBC,cAAA,KACxB,MAAA1E,CAAA,EAAA2E,UACA,CACAE,YAAApB,CAAA,EACA,KAAAnD,SAAA,CAAAwE,QAAA,CAAArB,KACA,KAAAnD,SAAA,CAAAjC,IAAA,CAAAoF,GACA,KAAAsB,cAAA,GACA,MAAAjF,CAAA,CAAAkF,MAAA,EAA2BxC,KAAA,gBAAAyC,MAAA,KAAAxB,SAAAA,CAAA,GAE3B,CACAyB,eAAAzB,CAAA,EACA,KAAAnD,SAAA,CAAAwE,QAAA,CAAArB,KACA,KAAAnD,SAAA,MAAAA,SAAA,CAAA6E,MAAA,IAAAZ,IAAAd,GACA,KAAAnD,SAAA,CAAA9B,MAAA,GACA,MAAAwB,CAAA,GACA,MAAAE,CAAA,CACA,MAAAF,CAAA,CAAA6C,MAAA,EAAmCuC,OAAA,KAEnC,MAAApF,CAAA,CAAAqF,WAAA,IAGA,KAAAxD,UAAA,IAEA,MAAA/B,CAAA,CAAAkF,MAAA,EAA2BxC,KAAA,kBAAAyC,MAAA,KAAAxB,SAAAA,CAAA,GAE3B,CACAG,mBAAA,CACA,YAAAtD,SAAA,CAAA9B,MAAA,CAEA8G,YAAA,CACA,KAAA1D,KAAA,CAAAH,aAAA,EACA,MAAAc,CAAA,EAAuBC,KAAA,cAEvB,CACA+C,MAAAlF,CAAA,CAAAmF,CAAA,EACA,iBAAA5D,KAAA,CAAAD,WAAA,EACA,iBAAAC,KAAA,CAAAjB,IAAA,EAAA6E,GAAAd,cACA,KAAA7B,MAAA,EAAsBO,OAAA,UACd,SAAApD,CAAA,CAER,OADA,MAAAA,CAAA,CAAAyF,aAAA,GACA,MAAAzF,CAAA,CAAA+B,OAAA,CAMA,GAHA1B,GACA,KAAAD,UAAA,CAAAC,GAEA,MAAAA,OAAA,CAAAwD,OAAA,EACA,IAAAJ,EAAA,KAAAnD,SAAA,CAAAgE,IAAA,IAAAC,EAAAlE,OAAA,CAAAwD,OAAA,EACAJ,GACA,KAAArD,UAAA,CAAAqD,EAAApD,OAAA,CAEA,CAQA,IAAAqF,EAAA,IAAAC,gBACAC,EAAA,IACAC,OAAAC,cAAA,CAAAC,EAAA,UACAC,WAAA,GACAC,IAAA,KACA,MAAA/F,CAAA,IACAwF,EAAAQ,MAAA,CAEA,EACA,EACAC,EAAA,KACA,IAAAtC,EAAsB,GAAAtH,EAAA6J,EAAA,EAAa,KAAA/F,OAAA,CAAAmF,GAUnCa,EAAAC,CATA,KACA,IAAAC,EAAA,CACAxG,OAAA,MAAAA,CAAA,CACAS,SAAA,KAAAA,QAAA,CACAsB,KAAA,KAAAA,IAAA,EAGA,OADA8D,EAAAW,GACAA,CACA,WAGA,CADA,MAAArG,CAAA,IACA,KAAAG,OAAA,CAAAmG,SAAA,EACA,KAAAnG,OAAA,CAAAmG,SAAA,CACA3C,EACAwC,EACA,MAGAxC,EAAAwC,EACA,EAaAI,EAAAC,CAZA,KACA,IAAAC,EAAA,CACAnB,aAAAA,EACAnF,QAAA,KAAAA,OAAA,CACAG,SAAA,KAAAA,QAAA,CACAT,OAAA,MAAAA,CAAA,CACA6B,MAAA,KAAAA,KAAA,CACAuE,QAAAA,CACA,EAEA,OADAP,EAAAe,GACAA,CACA,IAEA,MAAAtG,OAAA,CAAAuG,QAAA,EAAAC,QAAAJ,EAAA,MACA,MAAA5G,CAAA,MAAA+B,KAAA,CACA,eAAAA,KAAA,CAAAD,WAAA,OAAAC,KAAA,CAAAJ,SAAA,GAAAiF,EAAAjB,YAAA,EAAA1D,IAAA,GACA,MAAAS,CAAA,EAAuBC,KAAA,QAAAV,KAAA2E,EAAAjB,YAAA,EAAA1D,IAAA,GAEvB,IAAAgF,EAAA,IACY,GAAAC,EAAAC,EAAA,EAAgB7F,IAAAA,EAAAiC,MAAA,EAC5B,MAAAb,CAAA,EACAC,KAAA,QACArB,MAAAA,CACA,GAEW,GAAA4F,EAAAC,EAAA,EAAgB7F,KAC3B,MAAArB,CAAA,CAAAK,MAAA,CAAA2G,OAAA,GACA3F,EACA,MAEA,MAAArB,CAAA,CAAAK,MAAA,CAAA8G,SAAA,GACA,KAAArF,KAAA,CAAAjB,IAAA,CACAQ,EACA,OAGA,KAAAU,UAAA,EACA,EA4CA,OA3CA,MAAA7B,CAAA,CAAoB,GAAA+G,EAAAG,EAAA,EAAa,CACjCC,eAAA3B,GAAA2B,eACArI,GAAA2H,EAAAN,OAAA,CACAiB,MAAA1B,EAAA0B,KAAA,CAAA7H,IAAA,CAAAmG,GACA2B,UAAA,IACA,GAAA1G,KAAA,IAAAA,EAAA,CAMAmG,EAAA,SAA+B,KAAArG,SAAA,mBAAgB,IAC/C,MACA,CACA,IACA,KAAA2B,OAAA,CAAAzB,EACA,CAAU,MAAAQ,EAAA,CACV2F,EAAA3F,GACA,MACA,CACA,MAAArB,CAAA,CAAAK,MAAA,CAAAkH,SAAA,GAAA1G,EAAA,MACA,MAAAb,CAAA,CAAAK,MAAA,CAAA8G,SAAA,GACAtG,EACA,KAAAiB,KAAA,CAAAT,KAAA,CACA,MAEA,KAAAU,UAAA,EACA,EACAiF,QAAAA,EACAQ,OAAA,CAAAC,EAAApG,KACA,MAAAoB,CAAA,EAAyBC,KAAA,SAAA+E,aAAAA,EAAApG,MAAAA,CAAA,EACzB,EACAqG,QAAA,KACA,MAAAjF,CAAA,EAAyBC,KAAA,SACzB,EACAiF,WAAA,KACA,MAAAlF,CAAA,EAAyBC,KAAA,YACzB,EACAkF,MAAAjB,EAAApG,OAAA,CAAAqH,KAAA,CACAC,WAAAlB,EAAApG,OAAA,CAAAsH,UAAA,CACAC,YAAAnB,EAAApG,OAAA,CAAAuH,WAAA,CACAC,OAAA,MACA,GACA,MAAA7H,CAAA,CAAA8H,KAAA,EACA,CACA,CAAAvF,CAAA,CAAAwF,CAAA,EAoEA,KAAAnG,KAAA,CAAAoG,CAnEA,IACA,OAAAD,EAAAvF,IAAA,EACA,aACA,OACA,GAAAZ,CAAA,CACAN,kBAAAyG,EAAAR,YAAA,CACAhG,mBAAAwG,EAAA5G,KAAA,CAEA,aACA,OACA,GAAAS,CAAA,CACAD,YAAA,QACA,CACA,gBACA,OACA,GAAAC,CAAA,CACAD,YAAA,UACA,CACA,aACA,OACA,GAAAC,CAAA,CACA,GAAAqG,EAAArG,EAAAjB,IAAA,MAAAN,OAAA,EACAmB,UAAAuG,EAAAjG,IAAA,MACA,CACA,eAEA,OADA,MAAAjC,CAAA,QACA,CACA,GAAA+B,CAAA,CACAjB,KAAAoH,EAAApH,IAAA,CACAI,gBAAAa,EAAAb,eAAA,GACAC,cAAA+G,EAAA/G,aAAA,EAAAC,KAAAC,GAAA,GACAC,MAAA,KACAM,cAAA,GACAC,OAAA,UACA,IAAAqG,EAAArF,MAAA,GACAf,YAAA,OACAL,kBAAA,EACAC,mBAAA,IACA,EAEA,aACA,IAAAJ,EAAA4G,EAAA5G,KAAA,CACA,GAAc,GAAA4F,EAAAC,EAAA,EAAgB7F,IAAAA,EAAAiE,MAAA,QAAAvF,CAAA,CAC9B,OAAqB,SAAAA,CAAA,CAAA8B,YAAA,QAErB,OACA,GAAAC,CAAA,CACAT,MAAAA,EACAC,iBAAAQ,EAAAR,gBAAA,GACAC,eAAAJ,KAAAC,GAAA,GACAI,kBAAAM,EAAAN,iBAAA,GACAC,mBAAAJ,EACAQ,YAAA,OACAD,OAAA,OACA,CACA,kBACA,OACA,GAAAE,CAAA,CACAH,cAAA,EACA,CACA,gBACA,OACA,GAAAG,CAAA,CACA,GAAAmG,EAAAnG,KAAA,CAEA,CACA,GACA,KAAAA,KAAA,EACIsG,EAAAC,EAAa,CAAA1J,KAAA,MACjB,KAAA6B,SAAA,CAAAjD,OAAA,KACAoG,EAAA2E,aAAA,EACA,GACA,MAAAtI,CAAA,CAAAkF,MAAA,EAA2BC,MAAA,KAAAzC,KAAA,UAAAuF,OAAAA,CAAA,EAC3B,EACA,CACA,EACA,SAAAE,EAAAtH,CAAA,CAAAN,CAAA,EACA,OACAiB,kBAAA,EACAC,mBAAA,KACAI,YAAiB,GAAAoF,EAAAsB,EAAA,EAAQhI,EAAAuH,WAAA,sBACzB,GAAAjH,KAAA,IAAAA,GAAA,CACAQ,MAAA,KACAO,OAAA,SACA,EAEA,uEC7XA4G,EAAA,MACA,CAAAC,CAAA,CACApF,SAAA,CACA,KAAA4B,cAAA,EACA,CACAlD,YAAA,CACA,KAAAkD,cAAA,GACQ,GAAAyD,EAAAC,EAAA,EAAc,KAAAxG,MAAA,GACtB,OAAAsG,CAAA,CAAA7K,WAAA,KACA,KAAAwE,cAAA,EACA,EAAO,KAAAD,MAAA,EAEP,CACAD,aAAA0G,CAAA,EACA,KAAAzG,MAAA,CAAA0G,KAAAC,GAAA,CACA,KAAA3G,MAAA,IACAyG,GAAoBF,CAAAA,EAAAhM,EAAQ,CAAAqM,IAAA,KAE5B,CACA9D,gBAAA,CACA,MAAAwD,CAAA,GACAO,aAAA,MAAAP,CAAA,EACA,MAAAA,CAAA,QAEA,CACA,0JCtBA,SAAAQ,EAAAxB,CAAA,EACA,OAAAoB,KAAAK,GAAA,QAAAzB,EAAA,IACA,CACA,SAAA0B,EAAArB,CAAA,EACA,OAAAA,GAAA,sBAAkDsB,EAAAC,CAAa,CAAA3J,QAAA,EAC/D,CACA,IAAA4J,EAAA,cAAAC,MACAC,YAAAjJ,CAAA,EACA,wBACA,KAAA+E,MAAA,CAAA/E,GAAA+E,OACA,KAAAhC,MAAA,CAAA/C,GAAA+C,MACA,CACA,EACA,SAAAmG,EAAAC,CAAA,EACA,OAAAA,aAAAJ,CACA,CACA,SAAAK,EAAAtJ,CAAA,EACA,IAGAuJ,EAHAC,EAAA,GACApC,EAAA,EACAqC,EAAA,GAEAC,EAAmB,GAAAC,EAAAC,CAAA,IAanBC,EAAA,IAA4BC,EAAAC,CAAY,CAAA/M,SAAA,IAAAgD,CAAAA,WAAAA,EAAAyH,WAAA,EAAoDsB,EAAAC,CAAa,CAAA3J,QAAA,KAAAW,EAAA0H,MAAA,GACzGsC,EAAA,IAAAlB,EAAA9I,EAAAyH,WAAA,GAAAzH,EAAA0H,MAAA,GACA3E,EAAA,IACA0G,IACAA,EAAA,GACAzJ,EAAAkH,SAAA,GAAAmC,GACAE,MACAG,EAAA3G,OAAA,CAAAsG,GAEA,EACAY,EAAA,IACAR,IACAA,EAAA,GACAzJ,EAAA2G,OAAA,GAAA0C,GACAE,MACAG,EAAAO,MAAA,CAAAZ,GAEA,EACAa,EAAA,IACA,IAAApH,QAAA,IACAyG,EAAA,IACAE,CAAAA,GAAAI,GAAA,GACAM,EAAAd,EAEA,EACArJ,EAAAqH,OAAA,IACA,GAAK1E,IAAA,MACL4G,EAAA,OACAE,GACAzJ,EAAAsH,UAAA,IAEA,GAEA8C,EAAA,SAIAC,EAHA,GAAAZ,EACA,OAGA,IAAAzC,EAAAI,IAAAA,EAAApH,EAAAgH,cAAA,QACA,IACAqD,EAAArD,GAAAhH,EAAArB,EAAA,EACA,CAAM,MAAAqC,EAAA,CACNqJ,EAAAvH,QAAAmH,MAAA,CAAAjJ,EACA,CACA8B,QAAAC,OAAA,CAAAsH,GAAA1H,IAAA,CAAAI,GAAAF,KAAA,KACA,GAAA4G,EACA,OAEA,IAAAlC,EAAAvH,EAAAuH,KAAA,EAAqC+C,CAAAA,EAAAjO,EAAQ,MAC7CmL,EAAAxH,EAAAwH,UAAA,EAAAoB,EACA2B,EAAA,mBAAA/C,EAAAA,EAAAJ,EAAApG,GAAAwG,EACAgD,EAAAjD,CAAA,IAAAA,GAAA,iBAAAA,GAAAH,EAAAG,GAAA,mBAAAA,GAAAA,EAAAH,EAAApG,GACA,GAAAwI,GAAA,CAAAgB,EAAA,CACAP,EAAAjJ,GACA,MACA,CACAoG,IACApH,EAAAmH,MAAA,GAAAC,EAAApG,GACM,GAAAsJ,EAAAG,EAAA,EAAKF,GAAA5H,IAAA,KACXkH,IAAA,OAAAK,KACOvH,IAAA,MACP6G,EACAS,EAAAjJ,GAEAoJ,GAEA,EACA,EACA,EACA,OACAxI,QAAA8H,EACAhH,OAnFA,IACA+G,IACAQ,EAAA,IAAAhB,EAAAyB,IACA1K,EAAAiH,KAAA,KAEA,EA+EAzC,SAAA,KACA+E,MACAG,GAEAxE,YAlFA,KACAsE,EAAA,EACA,EAiFAlE,cAhFA,KACAkE,EAAA,EACA,EA+EAQ,SAAAA,EACArC,MAAA,KACAqC,IACAI,IAEAF,IAAAvH,IAAA,CAAAyH,GAEAV,EAEA,CACA,yDC9HA,IAAAiB,EAAA,MACAxB,aAAA,CACA,KAAAlM,SAAA,KAAA2N,IACA,KAAAC,SAAA,MAAAA,SAAA,CAAAzL,IAAA,MACA,CACAyL,UAAArO,CAAA,EAGA,OAFA,KAAAS,SAAA,CAAA6N,GAAA,CAAAtO,GACA,KAAAG,WAAA,GACA,KACA,KAAAM,SAAA,CAAA8N,MAAA,CAAAvO,GACA,KAAAK,aAAA,EACA,CACA,CACAC,cAAA,CACA,YAAAG,SAAA,CAAA+N,IAAA,EACA,CACArO,aAAA,CACA,CACAE,eAAA,CACA,CACA,yDCnBA,SAAAoO,QACAlI,EACAkH,EACA,IAAAP,EAAA,IAAA5G,QAAA,CAAAoI,EAAAC,KACApI,EAAAmI,EACAjB,EAAAkB,CACA,GAIA,SAAAC,EAAA5K,CAAA,EACAkF,OAAA2F,MAAA,CAAA3B,EAAAlJ,GACA,OAAAkJ,EAAA3G,OAAA,CACA,OAAA2G,EAAAO,MAAA,CAgBA,OAtBAP,EAAAnI,MAAA,WACAmI,EAAA7G,KAAA,MACA,GAMA6G,EAAA3G,OAAA,KACAqI,EAAA,CACA7J,OAAA,YACA8H,MAAAA,CACA,GACAtG,EAAAsG,EACA,EACAK,EAAAO,MAAA,KACAmB,EAAA,CACA7J,OAAA,WACA+J,OAAAA,CACA,GACArB,EAAAqB,EACA,EACA5B,CACA,kgBC/BA,IAAA6B,EAAA,oBAAAjP,QAAA,SAAAa,WACA,SAAAqO,IACA,CACA,SAAAC,EAAAC,CAAA,CAAAC,CAAA,EACA,yBAAAD,EAAAA,EAAAC,GAAAD,CACA,CACA,SAAAE,EAAAvC,CAAA,EACA,uBAAAA,GAAAA,GAAA,GAAAA,IAAAX,GACA,CACA,SAAAmD,EAAAvJ,CAAA,CAAAwB,CAAA,EACA,OAAA0E,KAAAC,GAAA,CAAAnG,EAAAwB,CAAAA,GAAA,GAAAhD,KAAAC,GAAA,KACA,CACA,SAAA+K,EAAAhI,CAAA,CAAAgB,CAAA,EACA,yBAAAhB,EAAAA,EAAAgB,GAAAhB,CACA,CACA,SAAAiI,EAAAxI,CAAA,CAAAuB,CAAA,EACA,yBAAAvB,EAAAA,EAAAuB,GAAAvB,CACA,CACA,SAAAyI,EAAAC,CAAA,CAAAnH,CAAA,EACA,IACAzC,KAAAA,EAAA,MACA6J,MAAAA,CAAA,CACA1K,YAAAA,CAAA,CACA2K,UAAAA,CAAA,CACA9L,SAAAA,CAAA,CACA+L,MAAAA,CAAA,CACA,CAAIH,EACJ,GAAA5L,GACA,GAAA6L,EACA,IAAApH,EAAAxE,SAAA,GAAA+L,EAAAhM,EAAAyE,EAAA5E,OAAA,EACA,QACA,MACM,IAAAoM,EAAAxH,EAAAzE,QAAA,CAAAA,GACN,SAGA,GAAAgC,QAAAA,EAAA,CACA,IAAAc,EAAA2B,EAAA3B,QAAA,GACA,cAAAd,GAAA,CAAAc,GAGAd,aAAAA,GAAAc,EAFA,QAKA,OACA,mBAAAiJ,GAAAtH,EAAAf,OAAA,KAAAqI,CAAA,GAGA5K,CAAAA,CAAAA,GAAAA,IAAAsD,EAAArD,KAAA,CAAAD,WAAA,GAGA2K,CAAAA,CAAAA,IAAA,CAAAA,EAAArH,EAAA,CAIA,CACA,SAAAyH,EAAAN,CAAA,CAAAO,CAAA,EACA,IAAUN,MAAAA,CAAA,CAAA3K,OAAAA,CAAA,CAAA4K,UAAAA,CAAA,CAAAM,YAAAA,CAAA,EAAwCR,EAClD,GAAAQ,EAAA,CACA,IAAAD,EAAAtM,OAAA,CAAAuM,WAAA,CACA,SAEA,GAAAP,EACA,IAAAQ,EAAAF,EAAAtM,OAAA,CAAAuM,WAAA,IAAAC,EAAAD,GACA,QACA,MACM,IAAAH,EAAAE,EAAAtM,OAAA,CAAAuM,WAAA,CAAAA,GACN,QAEA,OACAlL,CAAAA,CAAAA,GAAAiL,EAAA/K,KAAA,CAAAF,MAAA,GAAAA,CAAA,GAGA4K,CAAAA,CAAAA,IAAA,CAAAA,EAAAK,EAAA,CAIA,CACA,SAAAH,EAAAhM,CAAA,CAAAH,CAAA,EAEA,MAAAyM,CADAzM,GAAA0M,gBAAAF,CAAA,EACArM,EACA,CACA,SAAAqM,EAAArM,CAAA,EACA,OAAAwM,KAAAC,SAAA,CACAzM,EACA,CAAA0M,EAAAC,IAAAC,EAAAD,GAAAtH,OAAAwH,IAAA,CAAAF,GAAAG,IAAA,GAAAC,MAAA,EAAA7O,EAAA8O,KACA9O,CAAA,CAAA8O,EAAA,CAAAL,CAAA,CAAAK,EAAA,CACA9O,GACK,IAAIyO,EAET,CACA,SAAAV,EAAAgB,CAAA,CAAAC,CAAA,SACA,IAAAA,GAGA,OAAAD,GAAA,OAAAC,GAGAD,EAAAA,KAAAC,GAAA,iBAAAD,GAAA,iBAAAC,GACA7H,OAAAwH,IAAA,CAAAK,GAAAC,KAAA,IAAAlB,EAAAgB,CAAA,CAAAD,EAAA,CAAAE,CAAA,CAAAF,EAAA,EAGA,CA8BA,SAAAI,EAAAH,CAAA,CAAAC,CAAA,EACA,IAAAA,GAAA7H,OAAAwH,IAAA,CAAAI,GAAAjP,MAAA,GAAAqH,OAAAwH,IAAA,CAAAK,GAAAlP,MAAA,CACA,SAEA,QAAAgP,KAAAC,EACA,GAAAA,CAAA,CAAAD,EAAA,GAAAE,CAAA,CAAAF,EAAA,CACA,SAGA,QACA,CACA,SAAAK,EAAArE,CAAA,EACA,OAAAsE,MAAAC,OAAA,CAAAvE,IAAAA,EAAAhL,MAAA,GAAAqH,OAAAwH,IAAA,CAAA7D,GAAAhL,MAAA,CAEA,SAAA4O,EAAAY,CAAA,EACA,IAAAC,EAAAD,GACA,SAEA,IAAAE,EAAAF,EAAA1E,WAAA,CACA,GAAA4E,KAAA,IAAAA,EACA,SAEA,IAAAC,EAAAD,EAAAE,SAAA,UACAH,EAAAE,IAGAA,EAAAE,cAAA,oBAGAxI,OAAAyI,cAAA,CAAAN,KAAAnI,OAAAuI,SAAA,CAKA,SAAAH,EAAAD,CAAA,EACA,MAAAnI,oBAAAA,OAAAuI,SAAA,CAAAG,QAAA,CAAAC,IAAA,CAAAR,EACA,CACA,SAAAS,EAAAC,CAAA,EACA,WAAAzL,QAAA,IACAvF,WAAAwF,EAAAwL,EACA,EACA,CACA,SAAAC,EAAAC,CAAA,CAAAjO,CAAA,CAAAN,CAAA,QACA,mBAAAA,EAAAwO,iBAAA,CACAxO,EAAAwO,iBAAA,CAAAD,EAAAjO,GACIN,CAAA,IAAAA,EAAAwO,iBAAA,CAWJC,SArFAA,EAAArB,CAAA,CAAAC,CAAA,EACA,GAAAD,IAAAC,EACA,OAAAD,EAEA,IAAAsB,EAAAlB,EAAAJ,IAAAI,EAAAH,GACA,GAAAqB,GAAA3B,EAAAK,IAAAL,EAAAM,GAAA,CACA,IAAAsB,EAAAD,EAAAtB,EAAA5H,OAAAwH,IAAA,CAAAI,GACAwB,EAAAD,EAAAxQ,MAAA,CACA0Q,EAAAH,EAAArB,EAAA7H,OAAAwH,IAAA,CAAAK,GACAyB,EAAAD,EAAA1Q,MAAA,CACA4Q,EAAAL,EAAA,MACAM,EAAA,IAAAtE,IAAAiE,GACAM,EAAA,EACA,QAAAC,EAAA,EAAoBA,EAAAJ,EAAWI,IAAA,CAC/B,IAAA/B,EAAAuB,EAAAQ,EAAAL,CAAA,CAAAK,EAAA,CACA,EAAAR,GAAAM,EAAAG,GAAA,CAAAhC,IAAAuB,CAAA,GAAAtB,KAAA,IAAAA,CAAA,CAAAD,EAAA,EAAAE,KAAA,IAAAA,CAAA,CAAAF,EAAA,EACA4B,CAAA,CAAA5B,EAAA,QACA8B,MAEAF,CAAA,CAAA5B,EAAA,CAAAsB,EAAArB,CAAA,CAAAD,EAAA,CAAAE,CAAA,CAAAF,EAAA,EACA4B,CAAA,CAAA5B,EAAA,GAAAC,CAAA,CAAAD,EAAA,EAAAC,KAAA,IAAAA,CAAA,CAAAD,EAAA,EACA8B,IAGA,CACA,OAAAL,IAAAE,GAAAG,IAAAL,EAAAxB,EAAA2B,CACA,CACA,OAAA1B,CACA,EAyDAkB,EAAAjO,GAEAA,CACA,CAIA,SAAA8O,EAAAC,CAAA,CAAAC,CAAA,CAAA/G,EAAA,GACA,IAAAgH,EAAA,IAAAF,EAAAC,EAAA,CACA,OAAA/G,GAAAgH,EAAApR,MAAA,CAAAoK,EAAAgH,EAAAC,KAAA,IAAAD,CACA,CACA,SAAAE,EAAAJ,CAAA,CAAAC,CAAA,CAAA/G,EAAA,GACA,IAAAgH,EAAA,CAAAD,KAAAD,EAAA,CACA,OAAA9G,GAAAgH,EAAApR,MAAA,CAAAoK,EAAAgH,EAAAC,KAAA,OAAAD,CACA,CACA,IAAAG,EAAAC,SACA,SAAAC,EAAA5P,CAAA,CAAAmF,CAAA,QAQA,CAAAnF,EAAAwD,OAAA,EAAA2B,GAAA2B,eACA,IAAA3B,EAAA2B,cAAA,CAEA,EAAAtD,OAAA,EAAAxD,EAAAwD,OAAA,GAAAkM,EAGA1P,EAAAwD,OAAA,CAFA,IAAAZ,QAAAmH,MAAA,4BAA+D/J,EAAAI,SAAA,CAAkB,IAGjF,CACA,SAAAyP,EAAAC,CAAA,CAAAC,CAAA,QACA,mBAAAD,EACAA,KAAAC,GAEA,EAAAD,CACA,2GC7NaE,EAA2BC,EAAAA,aAAA,CACtC,QAGWC,EAAiB,IAC5B,IAAMxQ,EAAeuQ,EAAAA,UAAA,CAAWD,GAEhC,GAAIG,EACF,OAAOA,EAGT,GAAI,CAACzQ,EACH,MAAM,MAAU,0DAGlB,OAAOA,CACT,EAOa0Q,EAAsB,OAAC,CAClC1Q,OAAAA,CAAA,CACA2Q,SAAAA,CAAA,CACF,CAAAC,EAQE,OAPML,EAAAA,SAAA,CAAU,KACdvQ,EAAO6Q,KAAA,GACA,KACL7Q,EAAO8Q,OAAA,EACT,GACC,CAAC9Q,EAAO,EAGT+Q,CAAAA,EAAAA,EAAAA,GAAAA,EAACT,EAAmBU,QAAA,CAAnB,CAA4BvH,MAAOzJ,EACjC2Q,SAAAA,CAAA,EAGP,6BE7BMM,wGDCNC,EAAA,cAAkCC,EAAA/U,CAAY,CAC9CmN,YAAAvJ,CAAA,CAAAM,CAAA,EACA,QACA,KAAAA,OAAA,CAAAA,EACA,MAAAN,CAAA,CAAAA,EACA,MAAAoR,CAAA,MACA,MAAAC,CAAA,CAA4B,GAAAvH,EAAAE,CAAA,IAC5B,KAAA1J,OAAA,CAAAgR,6BAAA,EACA,MAAAD,CAAA,CAAAhH,MAAA,CACA,oEAGA,KAAAkH,WAAA,GACA,KAAAlR,UAAA,CAAAC,EACA,CACA,CAAAN,CAAA,EACAwR,CAAA,SACAC,CAAA,SACAC,CAAA,SACAC,CAAA,EACAC,CAAA,EACAP,CAAA,EACAD,CAAA,EACAS,CAAA,EACAC,CAAA,EAGAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,KAAAnH,GAAA,CACAuG,aAAA,CACA,KAAA7M,OAAA,MAAAA,OAAA,CAAAlF,IAAA,MACA,CACAzC,aAAA,CACA,SAAAM,SAAA,CAAA+N,IAAA,GACA,MAAAoG,CAAA,CAAA1M,WAAA,OACAsN,EAAA,MAAAZ,CAAA,MAAAlR,OAAA,EACA,MAAA+R,CAAA,GAEA,KAAAC,YAAA,GAEA,MAAAC,CAAA,GAEA,CACAtV,eAAA,CACA,KAAAC,YAAA,IACA,KAAAkG,OAAA,EAEA,CACAyB,wBAAA,CACA,OAAA2N,EACA,MAAAhB,CAAA,CACA,KAAAlR,OAAA,CACA,KAAAA,OAAA,CAAAmS,kBAAA,CAEA,CACAhO,0BAAA,CACA,OAAA+N,EACA,MAAAhB,CAAA,CACA,KAAAlR,OAAA,CACA,KAAAA,OAAA,CAAAoS,oBAAA,CAEA,CACAtP,SAAA,CACA,KAAA/F,SAAA,KAAA2N,IACA,MAAA2H,CAAA,GACA,MAAAC,CAAA,GACA,MAAApB,CAAA,CAAArM,cAAA,MACA,CACA9E,WAAAC,CAAA,EACA,IAAAuS,EAAA,KAAAvS,OAAA,CACAwS,EAAA,MAAAtB,CAAA,CAEA,GADA,KAAAlR,OAAA,OAAAN,CAAA,CAAA+S,mBAAA,CAAAzS,GACA,cAAAA,OAAA,CAAAqD,OAAA,yBAAArD,OAAA,CAAAqD,OAAA,0BAAArD,OAAA,CAAAqD,OAAA,mBAA6I,GAAAqP,EAAAvP,EAAA,EAAc,KAAAnD,OAAA,CAAAqD,OAAA,OAAA6N,CAAA,EAC3J,YACA,yEAGA,MAAAyB,CAAA,GACA,MAAAzB,CAAA,CAAAnR,UAAA,MAAAC,OAAA,EACAuS,EAAAK,UAAA,GAAmC,GAAAF,EAAAG,EAAA,EAAmB,KAAA7S,OAAA,CAAAuS,IACtD,MAAA7S,CAAA,CAAAQ,aAAA,GAAAyE,MAAA,EACAxC,KAAA,yBACAyC,MAAA,MAAAsM,CAAA,CACA9N,SAAA,OAGA,IAAA0P,EAAA,KAAAlW,YAAA,GACAkW,GAAAC,EACA,MAAA7B,CAAA,CACAsB,EACA,KAAAxS,OAAA,CACAuS,IAEA,MAAAR,CAAA,GAEA,KAAAC,YAAA,GACAc,GAAA,OAAA5B,CAAA,GAAAsB,GAAwD,GAAAE,EAAAvP,EAAA,EAAc,KAAAnD,OAAA,CAAAqD,OAAA,OAAA6N,CAAA,IAA+C,GAAAwB,EAAAvP,EAAA,EAAcoP,EAAAlP,OAAA,OAAA6N,CAAA,GAA6C,GAAAwB,EAAA/O,EAAA,EAAgB,KAAA3D,OAAA,CAAA4D,SAAA,OAAAsN,CAAA,IAAiD,GAAAwB,EAAA/O,EAAA,EAAgB4O,EAAA3O,SAAA,OAAAsN,CAAA,IACjQ,MAAA8B,CAAA,GAEA,IAAAC,EAAA,MAAAC,CAAA,GACAJ,GAAA,OAAA5B,CAAA,GAAAsB,GAAwD,GAAAE,EAAAvP,EAAA,EAAc,KAAAnD,OAAA,CAAAqD,OAAA,OAAA6N,CAAA,IAA+C,GAAAwB,EAAAvP,EAAA,EAAcoP,EAAAlP,OAAA,OAAA6N,CAAA,GAAA+B,IAAA,MAAArB,CAAA,GACnI,MAAAuB,CAAA,CAAAF,EAEA,CACAG,oBAAApT,CAAA,EACA,IAAA4E,EAAA,MAAAlF,CAAA,CAAAQ,aAAA,GAAAmT,KAAA,OAAA3T,CAAA,CAAAM,GACA3B,EAAA,KAAAiV,YAAA,CAAA1O,EAAA5E,GAMA,MAoUO,GAAA0S,EAAAG,EAAA,EAAmBzP,IAzU1B,CAyU0BU,gBAAA,GAzU1BzF,KACA,MAAA+S,CAAA,CAAA/S,EACA,MAAAiT,CAAA,MAAAtR,OAAA,CACA,MAAAqR,CAAA,OAAAH,CAAA,CAAA3P,KAAA,EAEAlD,CACA,CACAyF,kBAAA,CACA,aAAAsN,CAAA,CAEAmC,YAAAlV,CAAA,CAAAmV,CAAA,EACA,WAAAC,MAAApV,EAAA,CACAuH,IAAA,CAAA8N,EAAAvG,KACA,KAAAwG,SAAA,CAAAxG,GACAqG,IAAArG,GACAyG,QAAAhO,GAAA,CAAA8N,EAAAvG,GAEA,EACA,CACAwG,UAAAxG,CAAA,EACA,MAAA0E,CAAA,CAAAjH,GAAA,CAAAuC,EACA,CACA0G,iBAAA,CACA,aAAA3C,CAAA,CAEA9M,QAAA,CAAY,GAAApE,EAAA,CAAa,EAAI,EAC7B,YAAAkF,KAAA,EACA,GAAAlF,CAAA,EAEA,CACA8T,gBAAA9T,CAAA,EACA,IAAA+T,EAAA,MAAArU,CAAA,CAAA+S,mBAAA,CAAAzS,GACA4E,EAAA,MAAAlF,CAAA,CAAAQ,aAAA,GAAAmT,KAAA,OAAA3T,CAAA,CAAAqU,GACA,OAAAnP,EAAAM,KAAA,GAAAzC,IAAA,UAAA6Q,YAAA,CAAA1O,EAAAmP,GACA,CACA7O,MAAAC,CAAA,EACA,aAAA4M,CAAA,EACA,GAAA5M,CAAA,CACAd,cAAAc,EAAAd,aAAA,IACA,GAAK5B,IAAA,MACL,KAAAuP,YAAA,GACA,MAAAZ,CAAA,EAEA,CACA,CAAAW,CAAA,CAAA5M,CAAA,EACA,MAAAwN,CAAA,GACA,IAAAjR,EAAA,MAAAwP,CAAA,CAAAhM,KAAA,CACA,KAAAlF,OAAA,CACAmF,GAKA,OAHAA,GAAA2K,cACApO,CAAAA,EAAAA,EAAAiB,KAAA,CAA8B+P,EAAAhQ,EAAI,GAElChB,CACA,CACA,CAAAsR,CAAA,GACA,MAAAX,CAAA,GACA,IAAAzO,EAAsB,GAAA8O,EAAA/O,EAAA,EACtB,KAAA3D,OAAA,CAAA4D,SAAA,CACA,MAAAsN,CAAA,EAEA,GAAQwB,EAAAvW,EAAQ,QAAAiV,CAAA,CAAAvN,OAAA,GAAoC,GAAA6O,EAAAtK,EAAA,EAAcxE,GAClE,OAEA,IAAAoQ,EAAiB,GAAAtB,EAAA1O,EAAA,EAAc,MAAAoN,CAAA,CAAAzQ,aAAA,CAAAiD,EAE/B,OAAA8N,CAAA,CAAArU,WAAA,KACA,MAAA+T,CAAA,CAAAvN,OAAA,EACA,KAAAmO,YAAA,EAEA,EALAgC,EAAA,EAMA,CACA,CAAAd,CAAA,GACA,+BAAAlT,OAAA,CAAAiU,eAAA,MAAAjU,OAAA,CAAAiU,eAAA,OAAA/C,CAAA,OAAAlR,OAAA,CAAAiU,eAAA,KACA,CACA,CAAAd,CAAA,CAAAe,CAAA,EACA,MAAA5B,CAAA,GACA,MAAAV,CAAA,CAAAsC,GACQxB,EAAAvW,EAAQ,EAAI,CAAc,IAAd,GAAAuW,EAAAvP,EAAA,EAAc,KAAAnD,OAAA,CAAAqD,OAAA,OAAA6N,CAAA,GAAyD,GAAAwB,EAAAtK,EAAA,EAAc,MAAAwJ,CAAA,aAAAA,CAAA,EAGzG,OAAAD,CAAA,CAAAwC,YAAA,KACA,MAAAnU,OAAA,CAAAoU,2BAAA,EAAsDxY,EAAAiO,CAAY,CAAA/M,SAAA,KAClE,MAAAiV,CAAA,EAEA,EAAK,MAAAH,CAAA,EACL,CACA,CAAAK,CAAA,GACA,MAAAe,CAAA,GACA,MAAAG,CAAA,OAAAD,CAAA,GACA,CACA,CAAAb,CAAA,GACA,MAAAX,CAAA,GACAjJ,aAAA,MAAAiJ,CAAA,EACA,MAAAA,CAAA,QAEA,CACA,CAAAY,CAAA,GACA,MAAAX,CAAA,GACA0C,cAAA,MAAA1C,CAAA,EACA,MAAAA,CAAA,QAEA,CACA2B,aAAA1O,CAAA,CAAA5E,CAAA,MAWAM,EAVA,IAAAkS,EAAA,MAAAtB,CAAA,CACAqB,EAAA,KAAAvS,OAAA,CACAsU,EAAA,MAAAlD,CAAA,CACAmD,EAAA,MAAAlD,CAAA,CACAmD,EAAA,MAAAlD,CAAA,CAEAmD,EAAAC,IADAlC,EACA5N,EAAArD,KAAA,OAAA4P,CAAA,CACA,CAAY5P,MAAAA,CAAA,EAAQqD,EACpB+P,EAAA,CAAqB,GAAApT,CAAA,EACrBqT,EAAA,GAEA,GAAA5U,EAAA6U,kBAAA,EACA,IAAA/B,EAAA,KAAAlW,YAAA,GACAkY,EAAA,CAAAhC,GAAAhB,EAAAlN,EAAA5E,GACA+U,EAAAjC,GAAAC,EAAAnO,EAAA4N,EAAAxS,EAAAuS,GACAuC,CAAAA,GAAAC,CAAA,GACAJ,CAAAA,EAAA,CACA,GAAAA,CAAA,CACA,GAAa,GAAAK,EAAAC,CAAA,EAAU1T,EAAAjB,IAAA,CAAAsE,EAAA5E,OAAA,EACvB,EAEA,gBAAAA,EAAA6U,kBAAA,EACAF,CAAAA,EAAArT,WAAA,QAEA,CACA,IAAUR,MAAAA,CAAA,CAAAE,eAAAA,CAAA,CAAAK,OAAAA,CAAA,EAAgCsT,EAC1CrU,EAAAqU,EAAArU,IAAA,CACA,IAAA4U,EAAA,GACA,GAAAlV,KAAA,IAAAA,EAAAmV,eAAA,EAAA7U,KAAA,IAAAA,GAAAe,YAAAA,EAAA,CACA,IAAA8T,CACAb,CAAAA,GAAAM,mBAAA5U,EAAAmV,eAAA,GAAAX,GAAAW,iBACAA,EAAAb,EAAAhU,IAAA,CACA4U,EAAA,IAEAC,EAAA,mBAAAnV,EAAAmV,eAAA,CAAAnV,EAAAmV,eAAA,CACA,MAAA1D,CAAA,EAAAlQ,MAAAjB,KACA,MAAAmR,CAAA,EACAzR,EAAAmV,eAAA,CAEA,SAAAA,IACA9T,EAAA,UACAf,EAAe,GAAAoS,EAAAzQ,EAAA,EACfqS,GAAAhU,KACA6U,EACAnV,GAEA4U,EAAA,GAEA,CACA,GAAA5U,EAAAoV,MAAA,EAAA9U,KAAA,IAAAA,GAAA,CAAA4U,GACA,GAAAZ,GAAAhU,IAAAiU,GAAAjU,MAAAN,EAAAoV,MAAA,SAAA7D,CAAA,CACAjR,EAAA,MAAAkR,CAAA,MAEA,IACA,MAAAD,CAAA,CAAAvR,EAAAoV,MAAA,CACA9U,EAAAN,EAAAoV,MAAA,CAAA9U,GACAA,EAAiB,GAAAoS,EAAAzQ,EAAA,EAAWqS,GAAAhU,KAAAA,EAAAN,GAC5B,MAAAwR,CAAA,CAAAlR,EACA,MAAAwQ,CAAA,KACA,CAAU,MAAAA,EAAA,CACV,MAAAA,CAAA,CAAAA,CACA,EAGA,MAAAA,CAAA,GACAhQ,EAAA,MAAAgQ,CAAA,CACAxQ,EAAA,MAAAkR,CAAA,CACAxQ,EAAAJ,KAAAC,GAAA,GACAQ,EAAA,SAEA,IAAAgU,EAAAV,aAAAA,EAAArT,WAAA,CACAgU,EAAAjU,YAAAA,EACAkU,EAAAlU,UAAAA,EACAmU,EAAAF,GAAAD,EACA7U,EAAAF,KAAA,IAAAA,EACAjC,EAAA,CACAgD,OAAAA,EACAC,YAAAqT,EAAArT,WAAA,CACAgU,UAAAA,EACAG,UAAApU,YAAAA,EACAkU,QAAAA,EACAG,iBAAAF,EACAA,UAAAA,EACAlV,KAAAA,EACAK,cAAAgU,EAAAhU,aAAA,CACAG,MAAAA,EACAE,eAAAA,EACAkG,aAAAyN,EAAA1T,iBAAA,CACA0U,cAAAhB,EAAAzT,kBAAA,CACAH,iBAAA4T,EAAA5T,gBAAA,CACA6U,UAAAjB,EAAAjU,eAAA,IAAAiU,EAAA5T,gBAAA,GACA8U,oBAAAlB,EAAAjU,eAAA,CAAA+T,EAAA/T,eAAA,EAAAiU,EAAA5T,gBAAA,CAAA0T,EAAA1T,gBAAA,CACAsU,WAAAA,EACAS,aAAAT,GAAA,CAAAC,EACAS,eAAAR,GAAA,CAAA/U,EACAwV,SAAArB,WAAAA,EAAArT,WAAA,CACAsT,kBAAAA,EACAqB,eAAAV,GAAA/U,EACAqD,QAAAA,EAAAe,EAAA5E,GACAoE,QAAA,KAAAA,OAAA,CACA1C,QAAA,MAAAqP,CAAA,CACAmF,UAAiB,CAAc,IAAd,GAAAxD,EAAAvP,EAAA,EAAcnD,EAAAqD,OAAA,CAAAuB,EAC/B,EAEA,QAAA5E,OAAA,CAAAgR,6BAAA,EACA,IAAAmF,EAAA,IACAC,UAAAA,EAAA/U,MAAA,CACAmI,EAAAO,MAAA,CAAAqM,EAAAtV,KAAA,EACU,SAAAsV,EAAA9V,IAAA,EACVkJ,EAAA3G,OAAA,CAAAuT,EAAA9V,IAAA,CAEA,EACA+V,EAAA,KAEAF,EADA,MAAApF,CAAA,CAAAqF,EAAA1U,OAAA,CAAqE,GAAA8H,EAAAE,CAAA,IAErE,EACA4M,EAAA,MAAAvF,CAAA,CACA,OAAAuF,EAAAjV,MAAA,EACA,cACAuD,EAAAxE,SAAA,GAAAoS,EAAApS,SAAA,EACA+V,EAAAG,GAEA,KACA,iBACAF,CAAAA,UAAAA,EAAA/U,MAAA,EAAA+U,EAAA9V,IAAA,GAAAgW,EAAAnN,KAAA,GACAkN,IAEA,KACA,gBACAD,CAAAA,UAAAA,EAAA/U,MAAA,EAAA+U,EAAAtV,KAAA,GAAAwV,EAAAlL,MAAA,GACAiL,GAGA,CACA,CACA,OAhCAhY,CAiCA,CACA2T,cAAA,CACA,IAAAsC,EAAA,MAAAlD,CAAA,CACAgF,EAAA,KAAA9C,YAAA,OAAApC,CAAA,MAAAlR,OAAA,CACA,OAAAqR,CAAA,OAAAH,CAAA,CAAA3P,KAAA,CACA,MAAA+P,CAAA,MAAAtR,OAAA,CACA,eAAAqR,CAAA,CAAA/Q,IAAA,EACA,OAAAmR,CAAA,OAAAP,CAAA,EAEQ,GAAAwB,EAAAG,EAAA,EAAmBuD,EAAA9B,KAG3B,MAAAlD,CAAA,CAAAgF,EAsBA,MAAAzR,CAAA,EAAmB5H,UAAAwZ,CArBnB,KACA,IAAAjC,EACA,SAEA,IAAckC,oBAAAA,CAAA,EAAsB,KAAAxW,OAAA,CACpCyW,EAAA,mBAAAD,EAAAA,IAAAA,EACA,GAAAC,QAAAA,GAAA,CAAAA,GAAA,OAAA5E,CAAA,CAAA/G,IAAA,CACA,SAEA,IAAA4L,EAAA,IAAAhM,IACA+L,GAAA,MAAA5E,CAAA,EAKA,OAHA,KAAA7R,OAAA,CAAA8P,YAAA,EACA4G,EAAA9L,GAAA,UAEApF,OAAAwH,IAAA,OAAAoE,CAAA,EAAAlO,IAAA,IAGAyT,IADA,EAAAvF,CAAA,CADAjE,EACA,GAAAmH,CAAA,CADAnH,EACA,EACAuJ,EAAAvH,GAAA,CAFAhC,GAIA,IACmB,GACnB,CACA,CAAAwF,CAAA,GACA,IAAA/N,EAAA,MAAAlF,CAAA,CAAAQ,aAAA,GAAAmT,KAAA,OAAA3T,CAAA,MAAAM,OAAA,EACA,GAAA4E,IAAA,MAAAsM,CAAA,CACA,OAEA,IAAAsB,EAAA,MAAAtB,CAAA,CACA,MAAAA,CAAA,CAAAtM,EACA,MAAAuM,CAAA,CAAAvM,EAAArD,KAAA,CACA,KAAA3E,YAAA,KACA4V,GAAA3N,eAAA,MACAD,EAAAJ,WAAA,OAEA,CACAuD,eAAA,CACA,KAAAiK,YAAA,GACA,KAAApV,YAAA,IACA,MAAAqV,CAAA,EAEA,CACA,CAAAtN,CAAA,CAAAiS,CAAA,EACIrZ,EAAAuK,EAAa,CAAA1J,KAAA,MACjBwY,EAAA7Z,SAAA,EACA,KAAAA,SAAA,CAAAC,OAAA,KACAV,EAAA,MAAA8U,CAAA,CACA,GAEA,MAAA1R,CAAA,CAAAQ,aAAA,GAAAyE,MAAA,EACAC,MAAA,MAAAsM,CAAA,CACA/O,KAAA,wBACA,EACA,EACA,CACA,EAIA,SAAA2P,EAAAlN,CAAA,CAAA5E,CAAA,EACA,MAHuB,KAAd,GAAA0S,EAAAvP,EAAA,EAAcnD,EAAAqD,OAAA,CAGvBuB,IAHuBA,KAAA,IAAAA,EAAArD,KAAA,CAAAjB,IAAA,GAAAsE,CAAAA,UAAAA,EAAArD,KAAA,CAAAF,MAAA,EAAArB,CAAA,IAAAA,EAAA6W,YAAA,GAGvBjS,KAAA,IAAAA,EAAArD,KAAA,CAAAjB,IAAA,EAAA4R,EAAAtN,EAAA5E,EAAAA,EAAA8W,cAAA,CACA,CACA,SAAA5E,EAAAtN,CAAA,CAAA5E,CAAA,CAAA+W,CAAA,EACA,GAAM,CAAc,IAAd,GAAArE,EAAAvP,EAAA,EAAcnD,EAAAqD,OAAA,CAAAuB,IAAsC,cAAA8N,EAAA/O,EAAA,EAAgB3D,EAAA4D,SAAA,CAAAgB,GAAA,CAC1E,IAAAuE,EAAA,mBAAA4N,EAAAA,EAAAnS,GAAAmS,EACA,MAAA5N,WAAAA,GAAAA,CAAA,IAAAA,GAAAtF,EAAAe,EAAA5E,EACA,CACA,QACA,CACA,SAAA+S,EAAAnO,CAAA,CAAA4N,CAAA,CAAAxS,CAAA,CAAAuS,CAAA,EACA,OAAA3N,IAAA4N,GAAiC,CAAc,IAAd,GAAAE,EAAAvP,EAAA,EAAcoP,EAAAlP,OAAA,CAAAuB,EAAA,KAAA5E,EAAAgX,QAAA,EAAApS,UAAAA,EAAArD,KAAA,CAAAF,MAAA,GAAAwC,EAAAe,EAAA5E,EAC/C,CACA,SAAA6D,EAAAe,CAAA,CAAA5E,CAAA,EACA,MAAS,CAAc,IAAd,GAAA0S,EAAAvP,EAAA,EAAcnD,EAAAqD,OAAA,CAAAuB,IAAAA,EAAAb,aAAA,CAA0D,GAAA2O,EAAA/O,EAAA,EAAgB3D,EAAA4D,SAAA,CAAAgB,GACjG,mCCxaA,IAAMqS,EAAuChH,EAAAA,aAAA,EAdvCU,EAAU,GACP,CACLuG,WAAY,KACVvG,EAAU,EACZ,EACA3N,MAAO,KACL2N,EAAU,EACZ,EACAA,QAAS,IACAA,CAEX,IAOWwG,EAA6B,IAClClH,EAAAA,UAAA,CAAWgH,GCtBNG,EAAkC,CAO7CpX,EAOAqX,KAGErX,CAAAA,EAAQgX,QAAA,EACRhX,EAAQ8P,YAAA,EACR9P,EAAQgR,6BAAA,GAGJ,CAACqG,EAAmB1G,OAAA,IACtB3Q,CAAAA,EAAQ6W,YAAA,CAAe,GAG7B,EAEaS,EAA6B,IAGlCrH,EAAAA,SAAA,CAAU,KACdoH,EAAmBH,UAAA,EACrB,EAAG,CAACG,EAAmB,CACzB,EAEaE,EAAc,OAMzB,CACAlZ,OAAAA,CAAA,CACAgZ,mBAAAA,CAAA,CACAvH,aAAAA,CAAA,CACAlL,MAAAA,CAAA,CACAoS,SAAAA,CAAA,CACF,CAAA1G,EAOE,OACEjS,EAAOkX,OAAA,EACP,CAAC8B,EAAmB1G,OAAA,IACpB,CAACtS,EAAOgX,UAAA,EACRzQ,GACEoS,CAAAA,GAAY3Y,KAAgB,IAAhBA,EAAOiC,IAAA,EACnBuP,CAAAA,EAAAA,EAAAA,EAAAA,EAAiBC,EAAc,CAACzR,EAAOyC,KAAA,CAAO8D,EAAM,EAE1D,ECxEM4S,EAA2BvH,EAAAA,aAAA,CAAc,IAElCwH,EAAiB,IAAYxH,EAAAA,UAAA,CAAWuH,EAClBA,CAAAA,EAAmB9G,QAAA,CCJtD,IAAAgH,EAAA,IACA,GAAA3D,EAAAiD,QAAA,EACA,IAAAW,EAAA,GAAAxO,WAAAA,EAAAA,EAAAb,KAAAC,GAAA,CAAAY,GAAA,SACAyO,EAAA7D,EAAAnQ,SAAA,CACAmQ,EAAAnQ,SAAA,oBAAAgU,EAAA,IAAArZ,IAAAoZ,EAAAC,KAAArZ,IAAAoZ,EAAAC,GACA,iBAAA7D,EAAAnS,MAAA,EACAmS,CAAAA,EAAAnS,MAAA,CAAA0G,KAAAC,GAAA,CAAAwL,EAAAnS,MAAA,MAEA,CACA,EACAiW,EAAA,CAAAxZ,EAAAyZ,IAAAzZ,EAAAmX,SAAA,EAAAnX,EAAAgX,UAAA,GAAAyC,EACAC,EAAA,CAAAhE,EAAA1V,IAAA0V,GAAAiD,UAAA3Y,EAAAiX,SAAA,CACAxB,EAAA,CAAAC,EAAA3Q,EAAAiU,IAAAjU,EAAA0Q,eAAA,CAAAC,GAAApR,KAAA,MACA0U,EAAAH,UAAA,EACA,GEiCO,SAASc,EAAShY,CAAA,CAA0BmQ,CAAA,EACjD,OAAO8H,SDjBPjY,CAAA,CAOAkY,CAAA,CACA/H,CAAA,MAeEzQ,EAAAA,EAuFAA,EAAAA,EAcIA,EA1GN,IAAMoY,EAAcL,IACdJ,EAAqBF,IACrBzX,EAASwQ,CAAAA,EAAAA,EAAAA,EAAAA,EAAeC,GACxB4D,EAAmBrU,EAAO+S,mBAAA,CAAoBzS,EAEvB,QAA3BN,CAAAA,EAAAA,EAAOyY,iBAAA,GAAoBC,OAAA,GAA3B1Y,KAAAA,IAAAA,GAAAA,OAAAA,CAAAA,EAAAA,EAA4C2Y,yBAAA,GAA5C3Y,KAAAA,IAAAA,GAAAA,EAAAA,IAAAA,CAAAA,EACAqU,GAYFA,EAAiBc,kBAAA,CAAqBiD,EAClC,cACA,aAEJJ,EAAqB3D,GACrBqD,EAAgCrD,EAAkBsD,GAElDC,EAA2BD,GAG3B,IAAMiB,EAAkB,CAAC5Y,EACtBQ,aAAA,GACA0F,GAAA,CAAImO,EAAiB3T,SAAS,EAE3B,CAACgD,EAAQ,CAAU6M,EAAAA,QAAA,CACvB,IACE,IAAIiI,EACFxY,EACAqU,IAKA1V,EAAS+E,EAASgQ,mBAAA,CAAoBW,GAEtCwE,EAAkB,CAACT,GAAe9X,CAAuB,IAAvBA,EAAQwY,UAAA,CAyBhD,GAxBMvI,EAAAA,oBAAA,CACEA,EAAAA,WAAA,CACJ,IACE,IAAMwI,EAAcF,EAChBnV,EAASuH,SAAA,CAAUpN,EAAAA,EAAaA,CAACe,UAAA,CAAWoa,IAC5CpN,EAAAA,EAAIA,CAMR,OAFAlI,EAAS4O,YAAA,GAEFyG,CACT,EACA,CAACrV,EAAUmV,EAAe,EAE5B,IAAMnV,EAASU,gBAAA,GACf,IAAMV,EAASU,gBAAA,IAGXmM,EAAAA,SAAA,CAAU,KACd7M,EAASrD,UAAA,CAAWgU,EACtB,EAAG,CAACA,EAAkB3Q,EAAS,EAG3B2U,EAAchE,EAAkB1V,GAClC,MAAMyV,EAAgBC,EAAkB3Q,EAAUiU,GAIpD,GACEE,EAAY,CACVlZ,OAAAA,EACAgZ,mBAAAA,EACAvH,aAAciE,EAAiBjE,YAAA,CAC/BlL,MAAOlF,EACJQ,aAAA,GACA0F,GAAA,CAKCmO,EAAiB3T,SAAS,EAC9B4W,SAAUjD,EAAiBiD,QAAA,GAG7B,MAAM3Y,EAAOyC,KAAA,CAQf,GAL6B,OAA3BpB,CAAAA,EAAAA,EAAOyY,iBAAA,GAAoBC,OAAA,GAA3B1Y,KAAAA,IAAAA,GAAAA,OAAAA,CAAAA,EAAAA,EAA4CiZ,wBAAA,GAA5CjZ,KAAAA,IAAAA,GAAAA,EAAAA,IAAAA,CAAAA,EACAqU,EACA1V,GAIA0V,EAAiB/C,6BAAA,EACjB,CAAC3F,EAAAA,EAAQA,EACTwM,EAAUxZ,EAAQyZ,GAClB,CACA,IAAMpW,EAAU4W,EAEZxE,EAAgBC,EAAkB3Q,EAAUiU,GAAAA,OAE5C3X,CAAAA,EAAAA,EAAOQ,aAAA,GAAgB0F,GAAA,CAAImO,EAAiB3T,SAAS,IAArDV,KAAAA,IAAAA,EAAAA,KAAAA,EAAAA,EAAwDgC,OAAA,OAE5DA,GAAAA,EAASiB,KAAA,CAAM2I,EAAAA,EAAIA,EAAEsN,OAAA,CAAQ,KAE3BxV,EAAS4O,YAAA,EACX,EACF,CAGA,OAAO,EAAkBwE,mBAAA,CAErBnY,EADA+E,EAASmQ,WAAA,CAAYlV,EAE3B,ECvHsB2B,EAAS4Q,EAAeT,EAC9C","sources":["webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/focusManager.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/notifyManager.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/onlineManager.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/query.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/removable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/retryer.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/subscribable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/thenable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/utils.js","webpack://_N_E/../../src/QueryClientProvider.tsx","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/queryObserver.js","webpack://_N_E/../../src/QueryErrorResetBoundary.tsx","webpack://_N_E/../../src/errorBoundaryUtils.ts","webpack://_N_E/../../src/IsRestoringProvider.ts","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/suspense.js","webpack://_N_E/../../src/useBaseQuery.ts","webpack://_N_E/../../src/useQuery.ts"],"sourcesContent":["// src/focusManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar FocusManager = class extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\nexport {\n  FocusManager,\n  focusManager\n};\n//# sourceMappingURL=focusManager.js.map","// src/notifyManager.ts\nvar defaultScheduler = (cb) => setTimeout(cb, 0);\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = defaultScheduler;\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\nexport {\n  createNotifyManager,\n  defaultScheduler,\n  notifyManager\n};\n//# sourceMappingURL=notifyManager.js.map","// src/onlineManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar OnlineManager = class extends Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\nexport {\n  OnlineManager,\n  onlineManager\n};\n//# sourceMappingURL=onlineManager.js.map","// src/query.ts\nimport {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => resolveStaleTime(observer.options.staleTime, this) === \"static\"\n      );\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime(staleTime = 0) {\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n      const queryFnContext = createQueryFnContext();\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n    const context = createFetchContext();\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      this.scheduleGc();\n    };\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          this.#revertState = void 0;\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query,\n  fetchState\n};\n//# sourceMappingURL=query.js.map","// src/removable.ts\nimport { isServer, isValidTimeout } from \"./utils.js\";\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\nexport {\n  Removable\n};\n//# sourceMappingURL=removable.js.map","// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = pendingThenable();\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\nexport {\n  CancelledError,\n  canFetch,\n  createRetryer,\n  isCancelledError\n};\n//# sourceMappingURL=retryer.js.map","// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\nexport {\n  Subscribable\n};\n//# sourceMappingURL=subscribable.js.map","// src/thenable.ts\nimport { noop } from \"./utils.js\";\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\nfunction tryResolveSync(promise) {\n  let data;\n  promise.then((result) => {\n    data = result;\n    return result;\n  }, noop)?.catch(noop);\n  if (data !== void 0) {\n    return { data };\n  }\n  return void 0;\n}\nexport {\n  pendingThenable,\n  tryResolveSync\n};\n//# sourceMappingURL=thenable.js.map","// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    const aItemsSet = new Set(aItems);\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItemsSet.has(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== \"production\") {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n        throw error;\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\nfunction shouldThrowError(throwOnError, params) {\n  if (typeof throwOnError === \"function\") {\n    return throwOnError(...params);\n  }\n  return !!throwOnError;\n}\nexport {\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  isPlainArray,\n  isPlainObject,\n  isServer,\n  isValidTimeout,\n  keepPreviousData,\n  matchMutation,\n  matchQuery,\n  noop,\n  partialMatchKey,\n  replaceData,\n  replaceEqualDeep,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  shouldThrowError,\n  skipToken,\n  sleep,\n  timeUntilStale\n};\n//# sourceMappingURL=utils.js.map","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n","// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    const clamp = (value) => value === \"static\" ? value : Math.max(value ?? 1e3, 1e3);\n    const originalStaleTime = defaultedOptions.staleTime;\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n"],"names":["focusManager","_subscribable_js__WEBPACK_IMPORTED_MODULE_0__","l","focused","cleanup","setup","_utils_js__WEBPACK_IMPORTED_MODULE_1__","sk","window","addEventListener","listener","onFocus","removeEventListener","onSubscribe","setEventListener","onUnsubscribe","hasListeners","setFocused","isFocused","listeners","forEach","globalThis","document","visibilityState","defaultScheduler","setTimeout","cb","notifyManager","createNotifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","scheduleFn","schedule","push","flush","originalQueue","length","batch","result","batchCalls","args","setNotifyFunction","fn","setBatchNotifyFunction","setScheduler","onlineManager","online","onlineListener","onOnline","offlineListener","setOnline","bind","isOnline","Query","_removable_js__WEBPACK_IMPORTED_MODULE_0__","F","initialState","revertState","cache","client","retryer","defaultOptions","abortSignalConsumed","config","setOptions","options","observers","getQueryCache","queryKey","queryHash","getDefaultState","data","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","error","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","status","fetchStatus","state","scheduleGc","meta","promise","updateGcTime","gcTime","optionalRemove","remove","setData","newData","oE","dispatch","type","updatedAt","manual","setState","setStateOptions","cancel","then","ZT","catch","Promise","resolve","destroy","silent","reset","isActive","some","Nc","observer","enabled","isDisabled","getObserversCount","queryFn","CN","isStatic","KC","staleTime","isStale","getCurrentResult","isStaleByTime","Kp","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","shouldFetchOnReconnect","addObserver","includes","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","continueRetry","abortController","AbortController","addSignalProperty","Object","defineProperty","object","enumerable","get","signal","fetchFn","cG","queryFnContext","createQueryFnContext","queryFnContext2","persister","context","createFetchContext","context2","behavior","onFetch","onError","_retryer_js__WEBPACK_IMPORTED_MODULE_2__","DV","onSettled","Mz","initialPromise","abort","onSuccess","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","action","reducer","fetchState","_notifyManager_js__WEBPACK_IMPORTED_MODULE_3__","Vr","onQueryUpdate","Kw","Removable","gcTimeout","_utils_js__WEBPACK_IMPORTED_MODULE_0__","PN","newGcTime","Math","max","Infinity","clearTimeout","defaultRetryDelay","min","canFetch","_onlineManager_js__WEBPACK_IMPORTED_MODULE_0__","N","CancelledError","Error","constructor","isCancelledError","value","createRetryer","continueFn","isRetryCancelled","isResolved","thenable","_thenable_js__WEBPACK_IMPORTED_MODULE_1__","O","canContinue","_focusManager_js__WEBPACK_IMPORTED_MODULE_2__","j","canStart","reject","pause","continueResolve","run","promiseOrValue","_utils_js__WEBPACK_IMPORTED_MODULE_3__","delay","shouldRetry","_v","cancelOptions","Subscribable","Set","subscribe","add","delete","size","pendingThenable","_resolve","_reject","finalize","assign","reason","isServer","noop","functionalUpdate","updater","input","isValidTimeout","timeUntilStale","resolveStaleTime","resolveEnabled","matchQuery","filters","exact","predicate","stale","hashQueryKeyByOptions","partialMatchKey","matchMutation","mutation","mutationKey","hashKey","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","key","a","b","every","shallowEqualObjects","isPlainArray","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","getPrototypeOf","toString","call","sleep","timeout","replaceData","prevData","structuralSharing","replaceEqualDeep","array","aItems","aSize","bItems","bSize","copy","aItemsSet","equalItems","i","has","addToEnd","items","item","newItems","slice","addToStart","skipToken","Symbol","ensureQueryFn","shouldThrowError","throwOnError","params","QueryClientContext","React","useQueryClient","queryClient","QueryClientProvider","children","param","mount","unmount","jsx","Provider","isReset","QueryObserver","subscribable","selectError","currentThenable","experimental_prefetchInRender","bindMethods","currentQuery","currentQueryInitialState","currentResult","currentResultState","currentResultOptions","selectFn","selectResult","lastQueryWithDefinedData","staleTimeoutId","refetchIntervalId","currentRefetchInterval","trackedProps","shouldFetchOnMount","executeFetch","updateResult","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","prevOptions","prevQuery","defaultQueryOptions","utils","updateQuery","_defaulted","VS","mounted","shouldFetchOptionally","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","trackResult","onPropTracked","Proxy","target","trackProp","Reflect","getCurrentQuery","fetchOptimistic","defaultedOptions","time","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","queryChange","newState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","modern_query","z","skipSelect","placeholderData","select","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","failureReason","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isEnabled","finalizeThenableIfPossible","nextResult","recreateThenable","prevThenable","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","changed","notifyOptions","retryOnMount","refetchOnMount","field","suspense","QueryErrorResetBoundaryContext","clearReset","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","IsRestoringContext","useIsRestoring","ensureSuspenseTimers","clamp","originalStaleTime","willFetch","isRestoring","shouldSuspend","useQuery","useBaseQuery","Observer","getDefaultOptions","queries","_experimental_beforeQuery","isNewCacheEntry","shouldSubscribe","subscribed","unsubscribe","onStoreChange","_experimental_afterQuery","finally"],"sourceRoot":""}