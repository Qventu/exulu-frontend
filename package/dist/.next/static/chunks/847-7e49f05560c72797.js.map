{"version":3,"file":"static/chunks/847-7e49f05560c72797.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js","webpack://_N_E/./node_modules/@apollo/client/core/ObservableQuery.js","webpack://_N_E/./node_modules/@apollo/client/core/equalByQuery.js","webpack://_N_E/./node_modules/@apollo/client/core/networkStatus.js","webpack://_N_E/./node_modules/@apollo/client/utilities/common/arrays.js","webpack://_N_E/./node_modules/@apollo/client/utilities/common/canonicalStringify.js","webpack://_N_E/./node_modules/@apollo/client/utilities/common/cloneDeep.js","webpack://_N_E/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js","webpack://_N_E/./node_modules/@apollo/client/utilities/graphql/directives.js","webpack://_N_E/./node_modules/@apollo/client/utilities/graphql/fragments.js","webpack://_N_E/./node_modules/@apollo/client/utilities/graphql/getFromAST.js","webpack://_N_E/./node_modules/@apollo/client/utilities/graphql/storeUtils.js","webpack://_N_E/./node_modules/@apollo/client/utilities/observables/iteration.js","webpack://_N_E/./node_modules/@apollo/client/utilities/observables/subclassing.js","webpack://_N_E/./node_modules/@wry/trie/lib/index.js","webpack://_N_E/./node_modules/graphql/language/visitor.mjs","webpack://_N_E/./node_modules/@wry/context/lib/slot.js","webpack://_N_E/./node_modules/@wry/context/lib/index.js","webpack://_N_E/./node_modules/optimism/lib/context.js","webpack://_N_E/./node_modules/optimism/lib/helpers.js","webpack://_N_E/./node_modules/optimism/lib/entry.js","webpack://_N_E/./node_modules/optimism/lib/dep.js","webpack://_N_E/./node_modules/optimism/lib/index.js","webpack://_N_E/./node_modules/zen-observable-ts/module.js"],"sourcesContent":["export function preventUnhandledRejection(promise) {\n    promise.catch(function () { });\n    return promise;\n}\n//# sourceMappingURL=preventUnhandledRejection.js.map","import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, preventUnhandledRejection, } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nimport { Slot } from \"optimism\";\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ (function (_super) {\n    __extends(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = this;\n        var startedInactive = ObservableQuery.inactiveOnCreation.getValue();\n        _this = _super.call(this, function (observer) {\n            _this._getOrCreateQuery();\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(_this.maskResult(last.result));\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        _this.dirty = false;\n        _this._getOrCreateQuery = function () {\n            if (startedInactive) {\n                queryManager[\"queries\"].set(_this.queryId, queryInfo);\n                startedInactive = false;\n            }\n            return _this.queryManager.getOrCreateQuery(_this.queryId);\n        };\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n        _this.maskResult = _this.maskResult.bind(_this);\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy) : _f;\n        _this.options = __assign(__assign({}, options), { \n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy, \n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = getOperationDefinition(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function () {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        /**\n         * An object containing the variables that were provided for the query.\n         */\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO: this code doesn’t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetDiff = function () {\n        this.queryInfo.resetDiff();\n    };\n    ObservableQuery.prototype.getCurrentFullResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            NetworkStatus.ready;\n        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) ||\n            // If this.options.query has @client(always: true) fields, we cannot\n            // trust diff.result, since it was read from the cache without running\n            // local resolvers (and it's too late to run resolvers now, since we must\n            // return a result synchronously).\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n            // Fall through.\n        }\n        else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        }\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if (equal(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete &&\n                    result.networkStatus === NetworkStatus.loading &&\n                    (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            // We need to check for both both `error` and `errors` field because there\n            // are cases where sometimes `error` is set, but not `errors` and\n            // vice-versa. This will be updated in the next major version when\n            // `errors` is deprecated in favor of `error`.\n            if (result.networkStatus === NetworkStatus.ready &&\n                (result.error || result.errors)) {\n                result.networkStatus = NetworkStatus.error;\n            }\n            if (globalThis.__DEV__ !== false &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        return this.maskResult(this.getCurrentFullResult(saveAsLastResult));\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var documentInfo = this.queryManager.getDocumentInfo(this.query);\n        var dataMasking = this.queryManager.dataMasking;\n        var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;\n        var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ?\n            !equalByQuery(query, this.last.result, newResult, this.variables)\n            : !equal(this.last.result, newResult);\n        return (resultIsDifferent || (variables && !equal(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || equal(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = getQueryDefinition(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(\n                    21,\n                    variables,\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n                );\n            }\n        }\n        if (variables && !equal(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n    };\n    /**\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n     */\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (__assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })))), { \n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\" });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            fetchMoreOptions.query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;\n        var isCached = this.options.fetchPolicy !== \"no-cache\";\n        if (!isCached) {\n            invariant(updateQuery, 22);\n        }\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n            .then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            if (isCached) {\n                // Performing this cache update inside a cache.batch transaction ensures\n                // any affected cache.watch watchers are notified at most once about any\n                // updates. Most watchers will be using the QueryInfo class, which\n                // responds to notifications by calling reobserveCacheFirst to deliver\n                // fetchMore cache results back to this ObservableQuery.\n                _this.queryManager.cache.batch({\n                    update: function (cache) {\n                        var updateQuery = fetchMoreOptions.updateQuery;\n                        if (updateQuery) {\n                            cache.updateQuery({\n                                query: _this.query,\n                                variables: _this.variables,\n                                returnPartialData: true,\n                                optimistic: false,\n                            }, function (previous) {\n                                return updateQuery(previous, {\n                                    fetchMoreResult: fetchMoreResult.data,\n                                    variables: combinedOptions.variables,\n                                });\n                            });\n                        }\n                        else {\n                            // If we're using a field policy instead of updateQuery, the only\n                            // thing we need to do is write the new data to the cache using\n                            // combinedOptions.variables (instead of this.variables, which is\n                            // what this.updateQuery uses, because it works by abusing the\n                            // original field value, keyed by the original variables).\n                            cache.writeQuery({\n                                query: combinedOptions.query,\n                                variables: combinedOptions.variables,\n                                data: fetchMoreResult.data,\n                            });\n                        }\n                    },\n                    onWatchUpdated: function (watch) {\n                        // Record the DocumentNode associated with any watched query whose\n                        // data were updated by the cache writes above.\n                        updatedQuerySet.add(watch.query);\n                    },\n                });\n            }\n            else {\n                // There is a possibility `lastResult` may not be set when\n                // `fetchMore` is called which would cause this to crash. This should\n                // only happen if we haven't previously reported a result. We don't\n                // quite know what the right behavior should be here since this block\n                // of code runs after the fetch result has executed on the network.\n                // We plan to let it crash in the meantime.\n                //\n                // If we get bug reports due to the `data` property access on\n                // undefined, this should give us a real-world scenario that we can\n                // use to test against and determine the right behavior. If we do end\n                // up changing this behavior, this may require, for example, an\n                // adjustment to the types on `updateQuery` since that function\n                // expects that the first argument always contains previous result\n                // data, but not `undefined`.\n                var lastResult = _this.getLast(\"result\");\n                var data = updateQuery(lastResult.data, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables,\n                });\n                _this.reportResult(__assign(__assign({}, lastResult), { networkStatus: originalNetworkStatus, loading: isNetworkRequestInFlight(originalNetworkStatus), data: data }), _this.variables);\n            }\n            return _this.maskResult(fetchMoreResult);\n        })\n            .finally(function () {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (isCached && !updatedQuerySet.has(_this.query)) {\n                _this.reobserveCacheFirst();\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, updateOptions) {\n                        return updateQuery(previous, __assign({ subscriptionData: subscriptionData }, updateOptions));\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && invariant.error(23, err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n        var mergedOptions = compact(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if (equal(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, NetworkStatus.setVariables);\n    };\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var _a = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }), result = _a.result, complete = _a.complete;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n            complete: !!complete,\n            previousData: result,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        var queryInfo = this._getOrCreateQuery();\n        queryInfo.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](queryInfo, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval || !this.hasObservers()) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        invariant(pollInterval, 24);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            var _a, _b;\n            if (_this.pollingInfo) {\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) &&\n                    !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !equal(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return (this.last = __assign({ result: this.queryManager.assumeImmutableResults ?\n                newResult\n                : cloneDeep(newResult), variables: variables }, (error ? { error: error } : null)));\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = \n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch ||\n            // The fetchMore method does not actually call the reobserve method, but,\n            // if it did, it would definitely use a disposable Concast.\n            newNetworkStatus === NetworkStatus.fetchMore ||\n            // Polling uses a disposable Concast so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = compact(this.options, newOptions || {});\n        var options = useDisposableConcast ?\n            // Disposable Concast fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !equal(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                (options.fetchPolicy === oldFetchPolicy ||\n                    // A `nextFetchPolicy` function has even higher priority, though,\n                    // so in that case `applyNextFetchPolicy` must be called.\n                    typeof options.nextFetchPolicy === \"function\")) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function () {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && __assign({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function (result) {\n                if (equal(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportResult(result, variables);\n                }\n            },\n            error: function (error) {\n                if (equal(_this.variables, variables)) {\n                    // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n                    // However, calling `concast.cancel` can inject another type of error, so we have to\n                    // wrap it again here.\n                    if (!isApolloError(error)) {\n                        error = new ApolloError({ networkError: error });\n                    }\n                    finishWaitingForOwnResult();\n                    _this.reportError(error, variables);\n                }\n            },\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentFullResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            iterateObserversSafely(this.observers, \"next\", this.maskResult(result));\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        iterateObserversSafely(this.observers, \"error\", (this.last.error = error));\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function (document) {\n        return this.queryManager.transform(document);\n    };\n    ObservableQuery.prototype.maskResult = function (result) {\n        return result && \"data\" in result ? __assign(__assign({}, result), { data: this.queryManager.maskOperation({\n                document: this.query,\n                data: result.data,\n                fetchPolicy: this.options.fetchPolicy,\n                id: this.queryId,\n            }) }) : result;\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetNotifications = function () {\n        this.cancelNotifyTimeout();\n        this.dirty = false;\n    };\n    ObservableQuery.prototype.cancelNotifyTimeout = function () {\n        if (this.notifyTimeout) {\n            clearTimeout(this.notifyTimeout);\n            this.notifyTimeout = void 0;\n        }\n    };\n    /** @internal */\n    ObservableQuery.prototype.scheduleNotify = function () {\n        var _this = this;\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        if (!this.notifyTimeout) {\n            this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);\n        }\n    };\n    /** @internal */\n    ObservableQuery.prototype.notify = function () {\n        this.cancelNotifyTimeout();\n        if (this.dirty) {\n            if (this.options.fetchPolicy == \"cache-only\" ||\n                this.options.fetchPolicy == \"cache-and-network\" ||\n                !isNetworkRequestInFlight(this.queryInfo.networkStatus)) {\n                var diff = this.queryInfo.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    // If this diff came from an optimistic transaction, deliver the\n                    // current cache data to the ObservableQuery, but don't perform a\n                    // reobservation, since oq.reobserveCacheFirst might make a network\n                    // request, and we never want to trigger network requests in the\n                    // middle of optimistic updates.\n                    this.observe();\n                }\n                else {\n                    // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n                    // using a temporary fetch policy of \"cache-first\", so complete cache\n                    // results have a chance to be delivered without triggering additional\n                    // network requests, even when options.fetchPolicy is \"network-only\"\n                    // or \"cache-and-network\". All other fetch policies are preserved by\n                    // this method, and are handled by calling oq.reobserve(). If this\n                    // reobservation is spurious, isDifferentFromLastResult still has a\n                    // chance to catch it before delivery to ObservableQuery subscribers.\n                    this.reobserveCacheFirst();\n                }\n            }\n        }\n        this.dirty = false;\n    };\n    // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n    // delivery of any new data from the cache, possibly falling back to the network\n    // if any cache data are missing. This allows _complete_ cache results to be\n    // delivered without also kicking off unnecessary network requests when\n    // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n    // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n    // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n    ObservableQuery.prototype.reobserveCacheFirst = function () {\n        var _a = this.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n        if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n            return this.reobserve({\n                fetchPolicy: \"cache-first\",\n                // Use a temporary nextFetchPolicy function that replaces itself with the\n                // previous nextFetchPolicy value and returns the original fetchPolicy.\n                nextFetchPolicy: function (currentFetchPolicy, context) {\n                    // Replace this nextFetchPolicy function in the options object with the\n                    // original this.options.nextFetchPolicy value.\n                    this.nextFetchPolicy = nextFetchPolicy;\n                    // If the original nextFetchPolicy value was a function, give it a\n                    // chance to decide what happens here.\n                    if (typeof this.nextFetchPolicy === \"function\") {\n                        return this.nextFetchPolicy(currentFetchPolicy, context);\n                    }\n                    // Otherwise go back to the original this.options.fetchPolicy.\n                    return fetchPolicy;\n                },\n            });\n        }\n        return this.reobserve();\n    };\n    /**\n     * @internal\n     * A slot used by the `useQuery` hook to indicate that `client.watchQuery`\n     * should not register the query immediately, but instead wait for the query to\n     * be started registered with the `QueryManager` when `useSyncExternalStore`\n     * actively subscribes to it.\n     */\n    ObservableQuery.inactiveOnCreation = new Slot();\n    return ObservableQuery;\n}(Observable));\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && invariant.error(25, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && invariant.debug(26, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n    return (fetchPolicy === \"network-only\" ||\n        fetchPolicy === \"no-cache\" ||\n        fetchPolicy === \"standby\");\n}\n//# sourceMappingURL=ObservableQuery.js.map","import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n    var aData = _a.data, aRest = __rest(_a, [\"data\"]);\n    var bData = _b.data, bRest = __rest(_b, [\"data\"]);\n    return (equal(aRest, bRest) &&\n        equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n            variables: variables,\n        }));\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n    if (aResult === bResult) {\n        return true;\n    }\n    var seenSelections = new Set();\n    // Returning true from this Array.prototype.every callback function skips the\n    // current field/subtree. Returning false aborts the entire traversal\n    // immediately, causing equalBySelectionSet to return false.\n    return selectionSet.selections.every(function (selection) {\n        // Avoid re-processing the same selection at the same level of recursion, in\n        // case the same field gets included via multiple indirect fragment spreads.\n        if (seenSelections.has(selection))\n            return true;\n        seenSelections.add(selection);\n        // Ignore @skip(if: true) and @include(if: false) fields.\n        if (!shouldInclude(selection, context.variables))\n            return true;\n        // If the field or (named) fragment spread has a @nonreactive directive on\n        // it, we don't care if it's different, so we pretend it's the same.\n        if (selectionHasNonreactiveDirective(selection))\n            return true;\n        if (isField(selection)) {\n            var resultKey = resultKeyNameFromField(selection);\n            var aResultChild = aResult && aResult[resultKey];\n            var bResultChild = bResult && bResult[resultKey];\n            var childSelectionSet = selection.selectionSet;\n            if (!childSelectionSet) {\n                // These are scalar values, so we can compare them with deep equal\n                // without redoing the main recursive work.\n                return equal(aResultChild, bResultChild);\n            }\n            var aChildIsArray = Array.isArray(aResultChild);\n            var bChildIsArray = Array.isArray(bResultChild);\n            if (aChildIsArray !== bChildIsArray)\n                return false;\n            if (aChildIsArray && bChildIsArray) {\n                var length_1 = aResultChild.length;\n                if (bResultChild.length !== length_1) {\n                    return false;\n                }\n                for (var i = 0; i < length_1; ++i) {\n                    if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n        }\n        else {\n            var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n            if (fragment) {\n                // The fragment might === selection if it's an inline fragment, but\n                // could be !== if it's a named fragment ...spread.\n                if (selectionHasNonreactiveDirective(fragment))\n                    return true;\n                return equalBySelectionSet(fragment.selectionSet, \n                // Notice that we reuse the same aResult and bResult values here,\n                // since the fragment ...spread does not specify a field name, but\n                // consists of multiple fields (within the fragment's selection set)\n                // that should be applied to the current result value(s).\n                aResult, bResult, context);\n            }\n        }\n    });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n    return (!!selection.directives && selection.directives.some(directiveIsNonreactive));\n}\nfunction directiveIsNonreactive(dir) {\n    return dir.name.value === \"nonreactive\";\n}\n//# sourceMappingURL=equalByQuery.js.map","/**\n * The current status of a query’s execution in our system.\n */\nexport var NetworkStatus;\n(function (NetworkStatus) {\n    /**\n     * The query has never been run before and the query is now currently running. A query will still\n     * have this network status even if a partial data result was returned from the cache, but a\n     * query was dispatched anyway.\n     */\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    /**\n     * If `setVariables` was called and a query was fired because of that then the network status\n     * will be `setVariables` until the result of that query comes back.\n     */\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    /**\n     * Indicates that `fetchMore` was called on this query and that the query created is currently in\n     * flight.\n     */\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    /**\n     * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n     * and the refetch request is currently in flight.\n     */\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    /**\n     * Indicates that a polling query is currently in flight. So for example if you are polling a\n     * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n     * a poll request has been sent but not resolved.\n     */\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    /**\n     * No request is in flight for this query, and no errors happened. Everything is OK.\n     */\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    /**\n     * No request is in flight for this query, but one or more errors were detected.\n     */\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(networkStatus) {\n    return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(networkStatus) {\n    return networkStatus === 7 || networkStatus === 8;\n}\n//# sourceMappingURL=networkStatus.js.map","// A version of Array.isArray that works better with readonly arrays.\nexport var isArray = Array.isArray;\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n//# sourceMappingURL=arrays.js.map","import { AutoCleanedStrongCache, cacheSizes, } from \"../../utilities/caching/index.js\";\nimport { registerGlobalCache } from \"../caching/getMemoryInternals.js\";\n/**\n * Like JSON.stringify, but with object keys always sorted in the same order.\n *\n * To achieve performant sorting, this function uses a Map from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little bit more memory for every\n * object encountered that has different (more, less, a different order of) keys\n * than in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem, so we provide\n * canonicalStringify.reset() as a way of clearing the cache.\n * */\nexport var canonicalStringify = Object.assign(function canonicalStringify(value) {\n    return JSON.stringify(value, stableObjectReplacer);\n}, {\n    reset: function () {\n        // Clearing the sortingMap will reclaim all cached memory, without\n        // affecting the logical results of canonicalStringify, but potentially\n        // sacrificing performance until the cache is refilled.\n        sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1000 /* defaultCacheSizes.canonicalStringify */);\n    },\n});\nif (globalThis.__DEV__ !== false) {\n    registerGlobalCache(\"canonicalStringify\", function () { return sortingMap.size; });\n}\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nvar sortingMap;\ncanonicalStringify.reset();\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key, value) {\n    if (value && typeof value === \"object\") {\n        var proto = Object.getPrototypeOf(value);\n        // We don't want to mess with objects that are not \"plain\" objects, which\n        // means their prototype is either Object.prototype or null. This check also\n        // prevents needlessly rearranging the indices of arrays.\n        if (proto === Object.prototype || proto === null) {\n            var keys = Object.keys(value);\n            // If keys is already sorted, let JSON.stringify serialize the original\n            // value instead of creating a new object with keys in the same order.\n            if (keys.every(everyKeyInOrder))\n                return value;\n            var unsortedKey = JSON.stringify(keys);\n            var sortedKeys = sortingMap.get(unsortedKey);\n            if (!sortedKeys) {\n                keys.sort();\n                var sortedKey = JSON.stringify(keys);\n                // Checking for sortedKey in the sortingMap allows us to share the same\n                // sorted array reference for all permutations of the same set of keys.\n                sortedKeys = sortingMap.get(sortedKey) || keys;\n                sortingMap.set(unsortedKey, sortedKeys);\n                sortingMap.set(sortedKey, sortedKeys);\n            }\n            var sortedObject_1 = Object.create(proto);\n            // Reassigning the keys in sorted order will cause JSON.stringify to\n            // serialize them in sorted order.\n            sortedKeys.forEach(function (key) {\n                sortedObject_1[key] = value[key];\n            });\n            return sortedObject_1;\n        }\n    }\n    return value;\n}\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(key, i, keys) {\n    return i === 0 || keys[i - 1] <= key;\n}\n//# sourceMappingURL=canonicalStringify.js.map","var toString = Object.prototype.toString;\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep(value) {\n    return cloneDeepHelper(value);\n}\nfunction cloneDeepHelper(val, seen) {\n    switch (toString.call(val)) {\n        case \"[object Array]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_1 = val.slice(0);\n            seen.set(val, copy_1);\n            copy_1.forEach(function (child, i) {\n                copy_1[i] = cloneDeepHelper(child, seen);\n            });\n            return copy_1;\n        }\n        case \"[object Object]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n            // possible in all JS environments, so we will assume they exist/work.\n            var copy_2 = Object.create(Object.getPrototypeOf(val));\n            seen.set(val, copy_2);\n            Object.keys(val).forEach(function (key) {\n                copy_2[key] = cloneDeepHelper(val[key], seen);\n            });\n            return copy_2;\n        }\n        default:\n            return val;\n    }\n}\n//# sourceMappingURL=cloneDeep.js.map","import { isNonNullObject } from \"./objects.js\";\nexport function deepFreeze(value) {\n    var workSet = new Set([value]);\n    workSet.forEach(function (obj) {\n        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n            Object.getOwnPropertyNames(obj).forEach(function (name) {\n                if (isNonNullObject(obj[name]))\n                    workSet.add(obj[name]);\n            });\n        }\n    });\n    return value;\n}\nfunction shallowFreeze(obj) {\n    if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {\n        try {\n            Object.freeze(obj);\n        }\n        catch (e) {\n            // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n            // they all throw a TypeError when you try, so we re-throw any exceptions\n            // that are not TypeErrors, since that would be unexpected.\n            if (e instanceof TypeError)\n                return null;\n            throw e;\n        }\n    }\n    return obj;\n}\nexport function maybeDeepFreeze(obj) {\n    if (globalThis.__DEV__ !== false) {\n        deepFreeze(obj);\n    }\n    return obj;\n}\n//# sourceMappingURL=maybeDeepFreeze.js.map","import { invariant } from \"../globals/index.js\";\nimport { visit, BREAK, Kind } from \"graphql\";\nexport function shouldInclude(_a, variables) {\n    var directives = _a.directives;\n    if (!directives || !directives.length) {\n        return true;\n    }\n    return getInclusionDirectives(directives).every(function (_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === \"Variable\") {\n            evaledValue =\n                variables && variables[ifArgument.value.name.value];\n            invariant(evaledValue !== void 0, 78, directive.name.value);\n        }\n        else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    });\n}\nexport function getDirectiveNames(root) {\n    var names = [];\n    visit(root, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nexport var hasAnyDirectives = function (names, root) {\n    return hasDirectives(names, root, false);\n};\nexport var hasAllDirectives = function (names, root) {\n    return hasDirectives(names, root, true);\n};\nexport function hasDirectives(names, root, all) {\n    var nameSet = new Set(names);\n    var uniqueCount = nameSet.size;\n    visit(root, {\n        Directive: function (node) {\n            if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n                return BREAK;\n            }\n        },\n    });\n    // If we found all the names, nameSet will be empty. If we only care about\n    // finding some of them, the < condition is sufficient.\n    return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\nexport function hasClientExports(document) {\n    return document && hasDirectives([\"client\", \"export\"], document, true);\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === \"skip\" || value === \"include\";\n}\nexport function getInclusionDirectives(directives) {\n    var result = [];\n    if (directives && directives.length) {\n        directives.forEach(function (directive) {\n            if (!isInclusionDirective(directive))\n                return;\n            var directiveArguments = directive.arguments;\n            var directiveName = directive.name.value;\n            invariant(directiveArguments && directiveArguments.length === 1, 79, directiveName);\n            var ifArgument = directiveArguments[0];\n            invariant(ifArgument.name && ifArgument.name.value === \"if\", 80, directiveName);\n            var ifValue = ifArgument.value;\n            // means it has to be a variable value if this is a valid @skip or @include directive\n            invariant(ifValue &&\n                (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"), 81, directiveName);\n            result.push({ directive: directive, ifArgument: ifArgument });\n        });\n    }\n    return result;\n}\n/** @internal */\nexport function getFragmentMaskMode(fragment) {\n    var _a, _b;\n    var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function (_a) {\n        var name = _a.name;\n        return name.value === \"unmask\";\n    });\n    if (!directive) {\n        return \"mask\";\n    }\n    var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function (_a) {\n        var name = _a.name;\n        return name.value === \"mode\";\n    });\n    if (globalThis.__DEV__ !== false) {\n        if (modeArg) {\n            if (modeArg.value.kind === Kind.VARIABLE) {\n                globalThis.__DEV__ !== false && invariant.warn(82);\n            }\n            else if (modeArg.value.kind !== Kind.STRING) {\n                globalThis.__DEV__ !== false && invariant.warn(83);\n            }\n            else if (modeArg.value.value !== \"migrate\") {\n                globalThis.__DEV__ !== false && invariant.warn(84, modeArg.value.value);\n            }\n        }\n    }\n    if (modeArg &&\n        \"value\" in modeArg.value &&\n        modeArg.value.value === \"migrate\") {\n        return \"migrate\";\n    }\n    return \"unmask\";\n}\n//# sourceMappingURL=directives.js.map","import { __assign, __spreadArray } from \"tslib\";\nimport { invariant, newInvariantError } from \"../globals/index.js\";\nimport { BREAK, visit } from \"graphql\";\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    // Build an array of all our fragment definitions that will be used for\n    // validations. We also do some validations on the other definitions in the\n    // document while building this list.\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        // Throw an error if we encounter an operation definition because we will\n        // define our own operation definition later on.\n        if (definition.kind === \"OperationDefinition\") {\n            throw newInvariantError(\n                85,\n                definition.operation,\n                definition.name ? \" named '\".concat(definition.name.value, \"'\") : \"\"\n            );\n        }\n        // Add our definition to the fragments array if it is a fragment\n        // definition.\n        if (definition.kind === \"FragmentDefinition\") {\n            fragments.push(definition);\n        }\n    });\n    // If the user did not give us a fragment name then let us try to get a\n    // name from a single fragment in the definition.\n    if (typeof actualFragmentName === \"undefined\") {\n        invariant(fragments.length === 1, 86, fragments.length);\n        actualFragmentName = fragments[0].name.value;\n    }\n    // Generate a query document with an operation that simply spreads the\n    // fragment inside of it.\n    var query = __assign(__assign({}, document), { definitions: __spreadArray([\n            {\n                kind: \"OperationDefinition\",\n                // OperationTypeNode is an enum\n                operation: \"query\",\n                selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                        {\n                            kind: \"FragmentSpread\",\n                            name: {\n                                kind: \"Name\",\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ], document.definitions, true) });\n    return query;\n}\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexport function getFragmentFromSelection(selection, fragmentMap) {\n    switch (selection.kind) {\n        case \"InlineFragment\":\n            return selection;\n        case \"FragmentSpread\": {\n            var fragmentName = selection.name.value;\n            if (typeof fragmentMap === \"function\") {\n                return fragmentMap(fragmentName);\n            }\n            var fragment = fragmentMap && fragmentMap[fragmentName];\n            invariant(fragment, 87, fragmentName);\n            return fragment || null;\n        }\n        default:\n            return null;\n    }\n}\nexport function isFullyUnmaskedOperation(document) {\n    var isUnmasked = true;\n    visit(document, {\n        FragmentSpread: function (node) {\n            isUnmasked =\n                !!node.directives &&\n                    node.directives.some(function (directive) { return directive.name.value === \"unmask\"; });\n            if (!isUnmasked) {\n                return BREAK;\n            }\n        },\n    });\n    return isUnmasked;\n}\n//# sourceMappingURL=fragments.js.map","import { invariant, newInvariantError } from \"../globals/index.js\";\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc) {\n    invariant(doc && doc.kind === \"Document\", 88);\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== \"FragmentDefinition\"; })\n        .map(function (definition) {\n        if (definition.kind !== \"OperationDefinition\") {\n            throw newInvariantError(89, definition.kind);\n        }\n        return definition;\n    });\n    invariant(operations.length <= 1, 90, operations.length);\n    return doc;\n}\nexport function getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"OperationDefinition\";\n    })[0];\n}\nexport function getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === \"OperationDefinition\" && !!definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"FragmentDefinition\";\n    });\n}\nexport function getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    invariant(queryDef && queryDef.operation === \"query\", 91);\n    return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n    invariant(doc.kind === \"Document\", 92);\n    invariant(doc.definitions.length <= 1, 93);\n    var fragmentDef = doc.definitions[0];\n    invariant(fragmentDef.kind === \"FragmentDefinition\", 94);\n    return fragmentDef;\n}\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === \"OperationDefinition\") {\n            var operation = definition.operation;\n            if (operation === \"query\" ||\n                operation === \"mutation\" ||\n                operation === \"subscription\") {\n                return definition;\n            }\n        }\n        if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n            // we do this because we want to allow multiple fragment definitions\n            // to precede an operation definition.\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw newInvariantError(95);\n}\nexport function getDefaultValues(definition) {\n    var defaultValues = Object.create(null);\n    var defs = definition && definition.variableDefinitions;\n    if (defs && defs.length) {\n        defs.forEach(function (def) {\n            if (def.defaultValue) {\n                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);\n            }\n        });\n    }\n    return defaultValues;\n}\n//# sourceMappingURL=getFromAST.js.map","import { newInvariantError } from \"../globals/index.js\";\nimport { isNonNullObject } from \"../common/objects.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\nimport { canonicalStringify } from \"../common/canonicalStringify.js\";\nexport function makeReference(id) {\n    return { __ref: String(id) };\n}\nexport function isReference(obj) {\n    return Boolean(obj && typeof obj === \"object\" && typeof obj.__ref === \"string\");\n}\nexport function isDocumentNode(value) {\n    return (isNonNullObject(value) &&\n        value.kind === \"Document\" &&\n        Array.isArray(value.definitions));\n}\nfunction isStringValue(value) {\n    return value.kind === \"StringValue\";\n}\nfunction isBooleanValue(value) {\n    return value.kind === \"BooleanValue\";\n}\nfunction isIntValue(value) {\n    return value.kind === \"IntValue\";\n}\nfunction isFloatValue(value) {\n    return value.kind === \"FloatValue\";\n}\nfunction isVariable(value) {\n    return value.kind === \"Variable\";\n}\nfunction isObjectValue(value) {\n    return value.kind === \"ObjectValue\";\n}\nfunction isListValue(value) {\n    return value.kind === \"ListValue\";\n}\nfunction isEnumValue(value) {\n    return value.kind === \"EnumValue\";\n}\nfunction isNullValue(value) {\n    return value.kind === \"NullValue\";\n}\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw newInvariantError(96, name.value, value.kind);\n    }\n}\nexport function storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    \"connection\",\n    \"include\",\n    \"skip\",\n    \"client\",\n    \"rest\",\n    \"export\",\n    \"nonreactive\",\n];\n// Default stable JSON.stringify implementation used by getStoreKeyName. Can be\n// updated/replaced with something better by calling\n// getStoreKeyName.setStringify(newStringifyFunction).\nvar storeKeyNameStringify = canonicalStringify;\nexport var getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n    if (args &&\n        directives &&\n        directives[\"connection\"] &&\n        directives[\"connection\"][\"key\"]) {\n        if (directives[\"connection\"][\"filter\"] &&\n            directives[\"connection\"][\"filter\"].length > 0) {\n            var filterKeys = directives[\"connection\"][\"filter\"] ?\n                directives[\"connection\"][\"filter\"]\n                : [];\n            filterKeys.sort();\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = args[key];\n            });\n            return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(storeKeyNameStringify(filteredArgs_1), \")\");\n        }\n        else {\n            return directives[\"connection\"][\"key\"];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        // We can't use `JSON.stringify` here since it's non-deterministic,\n        // and can lead to different store key names being created even though\n        // the `args` object used during creation has the same properties/values.\n        var stringifiedArgs = storeKeyNameStringify(args);\n        completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\".concat(key, \"(\").concat(storeKeyNameStringify(directives[key]), \")\");\n            }\n            else {\n                completeFieldName += \"@\".concat(key);\n            }\n        });\n    }\n    return completeFieldName;\n}, {\n    setStringify: function (s) {\n        var previous = storeKeyNameStringify;\n        storeKeyNameStringify = s;\n        return previous;\n    },\n});\nexport function argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nexport function resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nexport function getTypenameFromResult(result, selectionSet, fragmentMap) {\n    var fragments;\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n        var selection = _a[_i];\n        if (isField(selection)) {\n            if (selection.name.value === \"__typename\") {\n                return result[resultKeyNameFromField(selection)];\n            }\n        }\n        else if (fragments) {\n            fragments.push(selection);\n        }\n        else {\n            fragments = [selection];\n        }\n    }\n    if (typeof result.__typename === \"string\") {\n        return result.__typename;\n    }\n    if (fragments) {\n        for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {\n            var selection = fragments_1[_b];\n            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === \"string\") {\n                return typename;\n            }\n        }\n    }\n}\nexport function isField(selection) {\n    return selection.kind === \"Field\";\n}\nexport function isInlineFragment(selection) {\n    return selection.kind === \"InlineFragment\";\n}\n//# sourceMappingURL=storeUtils.js.map","export function iterateObserversSafely(observers, method, argument) {\n    // In case observers is modified during iteration, we need to commit to the\n    // original elements, which also provides an opportunity to filter them down\n    // to just the observers with the given method.\n    var observersWithMethod = [];\n    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });\n    observersWithMethod.forEach(function (obs) { return obs[method](argument); });\n}\n//# sourceMappingURL=iteration.js.map","import { Observable } from \"./Observable.js\";\nimport { canUseSymbol } from \"../common/canUse.js\";\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nexport function fixObservableSubclass(subclass) {\n    function set(key) {\n        // Object.defineProperty is necessary because the Symbol.species\n        // property is a getter by default in modern JS environments, so we\n        // can't assign to it with a normal assignment expression.\n        Object.defineProperty(subclass, key, { value: Observable });\n    }\n    if (canUseSymbol && Symbol.species) {\n        set(Symbol.species);\n    }\n    // The \"@@species\" string is used as a fake Symbol.species value in some\n    // polyfill systems (including the SymbolSpecies variable used by\n    // zen-observable), so we should set it as well, to be safe.\n    set(\"@@species\");\n    return subclass;\n}\n//# sourceMappingURL=subclassing.js.map","// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        }\n        else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key)\n            ? this.weak || (create ? this.weak = new WeakMap : void 0)\n            : this.strong || (create ? this.strong = new Map : void 0);\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=index.js.map","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isNode, QueryDocumentKeys } from './ast.mjs';\nimport { Kind } from './kinds.mjs';\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport const BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\n\nexport function visit(root, visitor, visitorKeys = QueryDocumentKeys) {\n  const enterLeaveMap = new Map();\n\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = { ...node };\n\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      path.push(key);\n    }\n\n    let result;\n\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving\n        ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get === void 0\n          ? void 0\n          : _enterLeaveMap$get.leave\n        : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get2 === void 0\n        ? void 0\n        : _enterLeaveMap$get2.enter;\n      result =\n        visitFn === null || visitFn === void 0\n          ? void 0\n          : visitFn.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack,\n      };\n      inArray = Array.isArray(node);\n      keys = inArray\n        ? node\n        : (_node$kind = visitorKeys[node.kind]) !== null &&\n          _node$kind !== void 0\n        ? _node$kind\n        : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n\n  return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave = {\n      enter(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n\n            const result =\n              (_enterList$i = enterList[i]) === null || _enterList$i === void 0\n                ? void 0\n                : _enterList$i.apply(visitors[i], args);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n\n      leave(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n\n            const result =\n              (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0\n                ? void 0\n                : _leaveList$i.apply(visitors[i], args);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      },\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\n\nexport function getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined,\n    };\n  } // { enter() {}, leave() {} }\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave,\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\n\n/* c8 ignore next 8 */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}\n","// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE = {};\nlet idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot {\n    constructor() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    hasValue() {\n        for (let context = currentContext; context; context = context.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context.slots) {\n                const value = context.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    }\n    getValue() {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    }\n    withValue(value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        const slots = {\n            __proto__: null,\n            [this.id]: value,\n        };\n        const parent = currentContext;\n        currentContext = { parent, slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    }\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    static bind(callback) {\n        const context = currentContext;\n        return function () {\n            const saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    }\n    // Immediately run a callback function without any captured context.\n    static noContext(callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            const saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    }\n};\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(() => globalThis) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(() => global) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost = host;\nexport const Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n//# sourceMappingURL=slot.js.map","import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const { bind, noContext } = Slot;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n    return function () {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject) => {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value) => invoke(boundNext, value);\n            const invokeThrow = (error) => invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method) => {\n            const fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n//# sourceMappingURL=index.js.map","import { Slot } from \"@wry/context\";\nexport const parentEntrySlot = new Slot();\nexport function nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\nexport { Slot };\nexport { bind as bindContext, noContext, setTimeout, asyncFromGen, } from \"@wry/context\";\n//# sourceMappingURL=context.js.map","export const { hasOwnProperty, } = Object.prototype;\nexport const arrayFromSet = Array.from ||\n    function (set) {\n        const array = [];\n        set.forEach(item => array.push(item));\n        return array;\n    };\nexport function maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { parentEntrySlot } from \"./context.js\";\nimport { maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nexport class Entry {\n    constructor(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        maybeUnsubscribe(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child) => {\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            arrayFromSet(this.deps).forEach(dep => dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = arrayFromSet(child.parents);\n        for (let i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child) => {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n//# sourceMappingURL=entry.js.map","import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet, } from \"./helpers.js\";\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n//# sourceMappingURL=dep.js.map","import { Trie } from \"@wry/trie\";\nimport { StrongCache } from \"@wry/caches\";\nimport { Entry } from \"./entry.js\";\nimport { parentEntrySlot } from \"./context.js\";\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\nexport { bindContext, noContext, nonReactive, setTimeout, asyncFromGen, Slot, } from \"./context.js\";\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\nexport { dep } from \"./dep.js\";\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nexport function defaultMakeCacheKey(...args) {\n    const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\nexport { Trie as KeyTrie };\n;\nconst caches = new Set();\nexport function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache, } = Object.create(null)) {\n    const cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, entry => entry.dispose())\n        : cacheOption;\n    const optimistic = function () {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = () => cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!parentEntrySlot.hasValue()) {\n            caches.forEach(cache => cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: () => cache.size,\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache,\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n//# sourceMappingURL=index.js.map","function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport { Observable };\n"],"names":["ObservableQuery_assign","Object","assign","ObservableQuery_hasOwnProperty","hasOwnProperty","ObservableQuery","_super","_a","queryManager","queryInfo","options","_this","startedInactive","inactiveOnCreation","getValue","call","observer","_getOrCreateQuery","subObserver","_subscription","_observer","error","defaultSubscriptionObserverErrorCallback","first","observers","size","add","last","result","next","maskResult","reobserve","catch","delete","tearDownQuery","Set","subscriptions","dirty","set","queryId","getOrCreateQuery","waitForOwnResult","skipCacheDataFor","fetchPolicy","isTornDown","subscribeToMore","bind","_b","defaultOptions","watchQuery","_d","_c","defaultFetchPolicy","_e","_f","initialFetchPolicy","tslib_es6","pi","generateQueryId","opDef","getFromAST","$H","query","queryName","name","value","ZT","defineProperty","prototype","get","lastQuery","enumerable","configurable","variables","Promise","resolve","reject","removeQuery","setTimeout","subscription","unsubscribe","subscribe","resetDiff","getCurrentFullResult","saveAsLastResult","lastResult","getLastResult","networkStatus","core_networkStatus","Ie","ready","loading","Oj","getDocumentInfo","hasForcedResolvers","diff","getDiff","complete","returnPartialData","data","lib","D","partial","errors","globalThis","__DEV__","partialRefetch","logMissingFieldErrors","missing","updateLastResult","getCurrentResult","isDifferentFromLastResult","newResult","documentInfo","dataMasking","nonReactiveQuery","resultIsDifferent","hasNonreactiveDirective","equalByQuery","W","getLast","key","variablesMustMatch","getLastError","resetLastResults","resetQueryStoreErrors","resetErrors","refetch","reobserveOptions","pollInterval","queryDef","iW","vars","variableDefinitions","some","v","variable","globals","kG","warn","resetLastWrite","fetchMore","fetchMoreOptions","combinedOptions","transformDocument","qid","originalNetworkStatus","notifyOnNetworkStatusChange","observe","updatedQuerySet","updateQuery","isCached","fetchQuery","then","fetchMoreResult","cache","batch","update","optimistic","previous","writeQuery","onWatchUpdated","watch","reportResult","finally","has","reobserveCacheFirst","startGraphQLSubscription","document","context","subscriptionData","updateOptions","err","onError","setOptions","newOptions","silentSetOptions","mergedOptions","compact","o","setVariables","mapFn","previousData","broadcastQueries","startPolling","updatePolling","stopPolling","applyNextFetchPolicy","reason","nextFetchPolicy","observable","fetch","newNetworkStatus","setObservableQuery","ssrMode","pollingInfo","hasObservers","clearTimeout","timeout","interval","info","maybeFetch","skipPollAttempt","poll","assumeImmutableResults","cloneDeep","X","reobserveAsConcast","useDisposableConcast","oldVariables","oldFetchPolicy","finishWaitingForOwnResult","concast","fromLink","MS","cA","networkError","reportError","removeObserver","addObserver","promise","resubscribeAfterError","args","_i","arguments","length","apply","lastError","isDifferent","iteration","p","errorResult","graphQLErrors","forEach","sub","clear","stopQuery","transform","maskOperation","id","resetNotifications","cancelNotifyTimeout","notifyTimeout","scheduleNotify","notify","fromOptimisticTransaction","currentFetchPolicy","optimism_lib","g7","zen_observable_ts_module","y","message","stack","debug","subclassing","aData","aRest","tslib__WEBPACK_IMPORTED_MODULE_1__","_T","bData","bRest","_wry_equality__WEBPACK_IMPORTED_MODULE_0__","Z","equalBySelectionSet","selectionSet","aResult","bResult","seenSelections","selections","every","selection","_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__","LZ","selectionHasNonreactiveDirective","_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__","My","resultKey","u2","aResultChild","bResultChild","childSelectionSet","aChildIsArray","Array","isArray","bChildIsArray","length_1","i","fragment","_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__","hi","fragmentMap","_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__","p$","F","kU","directives","directiveIsNonreactive","dir","NetworkStatus","isNetworkRequestInFlight","isNonEmptyArray","sortingMap","canonicalStringify","JSON","stringify","stableObjectReplacer","reset","_utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_0__","L","_utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_1__","Q","proto","getPrototypeOf","keys","everyKeyInOrder","unsortedKey","sortedKeys","sort","sortedKey","sortedObject_1","create","_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_2__","zP","toString","cloneDeepHelper","val","seen","Map","copy_1","slice","child","copy_2","maybeDeepFreeze","obj","workSet","_objects_js__WEBPACK_IMPORTED_MODULE_0__","s","shallowFreeze","isFrozen","freeze","e","TypeError","getOwnPropertyNames","shouldInclude","getInclusionDirectives","directive","directiveArguments","directiveName","_globals_index_js__WEBPACK_IMPORTED_MODULE_0__","ifArgument","ifValue","kind","push","evaledValue","hasDirectives","names","root","all","nameSet","uniqueCount","graphql__WEBPACK_IMPORTED_MODULE_1__","Vn","Directive","node","$_","hasClientExports","getFragmentMaskMode","find","modeArg","graphql__WEBPACK_IMPORTED_MODULE_2__","h","VARIABLE","STRING","getFragmentQueryDocument","fragmentName","actualFragmentName","fragments","definitions","definition","_K","operation","concat","ev","createFragmentMap","symTable","getFragmentFromSelection","isFullyUnmaskedOperation","isUnmasked","FragmentSpread","checkDocument","doc","operations","filter","d","map","getOperationDefinition","getOperationName","x","getFragmentDefinitions","getQueryDefinition","getFragmentDefinition","fragmentDef","getMainDefinition","queryDoc","fragmentDefinition","getDefaultValues","defaultValues","defs","def","defaultValue","_storeUtils_js__WEBPACK_IMPORTED_MODULE_1__","vb","getTypenameFromResult","isField","resultKeyNameFromField","__typename","fragments_1","typename","_fragments_js__WEBPACK_IMPORTED_MODULE_3__","makeReference","__ref","String","isReference","Boolean","isDocumentNode","_common_objects_js__WEBPACK_IMPORTED_MODULE_1__","valueToObjectRepresentation","argObj","isIntValue","Number","isBooleanValue","nestedArgObj_1","fields","variableValue","values","listValue","nestedArgArrayObj","storeKeyNameFromField","field","directivesObj","getStoreKeyName","KNOWN_DIRECTIVES","storeKeyNameStringify","_common_canonicalStringify_js__WEBPACK_IMPORTED_MODULE_2__","B","fieldName","filterKeys","filteredArgs_1","completeFieldName","stringifiedArgs","indexOf","setStringify","argumentsObjectFromField","argObj_1","alias","isInlineFragment","iterateObserversSafely","method","argument","observersWithMethod","obs","fixObservableSubclass","subclass","_Observable_js__WEBPACK_IMPORTED_MODULE_0__","_common_canUse_js__WEBPACK_IMPORTED_MODULE_1__","aS","Symbol","species","defaultMakeData","Trie","constructor","weakness","makeData","lookup","lookupArray","array","getChildTrie","peek","peekArray","len","mapFor","remove","removeArray","head","weak","strong","isObjRef","WeakMap","BREAK","visit","visitor","visitorKeys","_ast_mjs__WEBPACK_IMPORTED_MODULE_0__","h8","parent","enterLeaveMap","_kinds_mjs__WEBPACK_IMPORTED_MODULE_1__","getEnterLeaveForKind","inArray","index","edits","path","ancestors","_enterLeaveMap$get","_enterLeaveMap$get2","_node$kind","isLeaving","isEdited","undefined","pop","editOffset","editKey","editValue","arrayKey","splice","prev","UG","_jsutils_devAssert_mjs__WEBPACK_IMPORTED_MODULE_2__","a","_jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_3__","visitFn","leave","enter","visitInParallel","visitors","skipping","fill","mergedVisitor","hasVisitor","enterList","leaveList","mergedEnterLeave","_enterList$i","_leaveList$i","kindVisitor","defaultKeyTrie","currentContext","MISSING_VALUE","idCounter","maybe","fn","ignored","globalKey","host","global","Slot","globalHost","writable","Date","now","Math","random","join","hasValue","slots","withValue","callback","thisArg","__proto__","saved","noContext","parentEntrySlot","helpers_hasOwnProperty","arrayFromSet","from","item","maybeUnsubscribe","entryOrDep","emptySetPool","assert","condition","optionalMessage","valueIs","b","valueGet","Entry","parents","childValues","dirtyChildren","recomputing","deps","count","mightBeDirty","rememberParent","recompute","forgetChildren","recomputeNewValue","maybeSubscribe","entry","setDirty","eachParent","reportCleanChild","reportDirtyChild","dispose","forgetChild","forget","dependOn","dep","forgetDeps","oldValueCopy","normalizeResult","parentCount","parentWasClean","childValue","removeDirtyChild","dc","_value","EntryMethods","depsByKey","depend","entryMethodName","m","defaultMakeCacheKey","trie","caches","wrap","originalFunction","max","keyArgs","makeCacheKey","cacheOption","clean","dirtyKey","peekKey","forgetKey","getKey","_arrayLikeToArray","arr","arr2","_defineProperties","target","props","descriptor","_createClass","Constructor","protoProps","staticProps","hasSymbols","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","ctor","Observable","hostReportError","log","enqueue","cleanupSubscription","cleanup","_cleanup","closeSubscription","_queue","_state","notifySubscription","type","onNotify","flushSubscription","queue","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","_proto","_proto2","_subscriber","_proto3","done","_this2","_this3","reduce","_this4","C","hasSeed","seed","acc","_this5","_len","sources","_key","startNext","flatMap","_this6","outer","inner","completeIfDone","closed","_step","_iterator","_createForOfIteratorHelperLoose","allowArrayLike","it","iterator","_unsupportedIterableToArray","minLen","n","test","of","_len2","items","_key2","symbol"],"sourceRoot":""}